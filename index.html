<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEMINI CHAT</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: black;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .gradient-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            overflow: hidden;
        }

        .gradient-set {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 5s ease;
        }

        .gradient, .gradient-2, .gradient-3 {
            position: absolute;
            border-radius: 50%;
            filter: blur(20px);
        }

        .gradient {
            width: 150%;
            height: 150%;
            top: -25%;
            left: -25%;
            animation: rotate 30s infinite linear;
        }

        .gradient-2 {
            width: 140%;
            height: 140%;
            top: -20%;
            left: -20%;
            animation: rotate 25s infinite linear reverse;
        }

        .gradient-3 {
            width: 130%;
            height: 130%;
            top: -15%;
            left: -15%;
            animation: rotate 35s infinite linear;
        }

        /* Glass container styles */
        .glass-container {
            position: relative;
            width: 95vw;
            height: 100vh;
            margin: 0 auto;
            left: 0;
            right: 0;
            z-index: 1;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            border-radius: 32px;
            border: 1px solid rgba(255,255,255,0.06);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4) inset;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .chat-header {
            padding: 15px 20px;
            background: rgba(255,255,255,0.05);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .header-left {
            flex: 1;
        }

        .chat-title {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 4px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .username {
            font-size: 14px;
            opacity: 0.8;
        }

        .connection-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff3b30;
            box-shadow: 0 0 8px #ff3b30;
        }

        .connection-indicator.connected {
            background-color: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .connection-indicator.unavailable {
            background-color: #ff9500;
            box-shadow: 0 0 8px #ff9500;
        }

        .typing-indicator {
            font-size: 12px;
            opacity: 0.7;
            font-style: italic;
            display: none;
        }

        .header-right {
            display: flex;
            gap: 12px;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .header-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 20px;
            font-size: 15px;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(20px);
            animation: messageAppear 0.5s forwards;
        }

        .message.user {
            align-self: flex-end;
            background: rgba(120, 80, 200, 0.2);
            border: 1px solid rgba(120, 80, 200, 0.3);
        }

        .message.bot {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timestamp {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 4px;
            text-align: right;
        }

        .chat-input-container {
            display: flex;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border-radius: 24px;
            border: none;
            outline: none;
            background: rgba(255,255,255,0.08);
            color: white;
            margin-right: 10px;
        }

        .input-buttons {
            display: flex;
            gap: 8px;
        }

        .input-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        .attach-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .send-btn {
            background: rgba(120, 80, 200, 0.3);
            color: white;
        }

        .input-btn:hover {
            transform: scale(1.05);
        }

        .send-btn:hover {
            background: rgba(120, 80, 200, 0.5);
        }

        /* Modal styles */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-weight: bold;
            font-size: 18px;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background: rgba(120, 80, 200, 0.3);
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.3s ease;
        }

        .modal-btn:hover {
            background: rgba(120, 80, 200, 0.5);
        }

        .video-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            align-items: center;
        }

        .video-box {
            width: 95%;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .video-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        .video-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        .stream-video {
            width: 100%;
            max-height: 40vh;
            object-fit: contain;
        }

        /* Video Call Layout */
        .video-call-container {
            position: relative;
            width: 70vw;
            height: 80vh;
            margin: 20px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .local-video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 20vw;
            height: 25vh;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .local-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .connection-status {
            margin-top: 15px;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 14px;
        }

        .developer-credit {
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
        }

        .form-group {
            margin-bottom: 15px;
            width: 100%;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            opacity: 0.8;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            color: white;
        }

        .stream-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
            align-items: center;
        }

        .stream-buttons {
            display: flex;
            gap: 10px;
        }

        .files-container {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 10px;
            width: 100%;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .save-btn {
            margin-top: 10px;
            width: 100%;
        }

        .modal-fullscreen-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .file-input {
            display: none;
        }

        .modal-header-right {
            display: flex;
            gap: 10px;
        }

        .selected-file-info {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }

        .transfer-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
            width: 100%;
        }

        .transfer-item {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .transfer-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 6px;
        }

        .transfer-name {
            font-weight: bold;
            word-break: break-all;
            font-size: 14px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress[data-type="send"] {
            background: #4CAF50;
        }

        .progress[data-type="recv"] {
            background: #2196F3;
        }

        .file-link {
            display: inline-block;
            margin-top: 6px;
            text-decoration: underline;
            color: #2196F3;
            cursor: pointer;
            font-size: 12px;
        }

        /* File Preview Modal */
        .preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .preview-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .preview-content {
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .preview-content img {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
        }

        .preview-content video {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
            background: #000;
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .player-controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
        }

        .player-controls input[type="range"] {
            flex: 1;
            height: 5px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            outline: none;
        }

        .back-btn {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
        }

        /* Incoming Call Modal */
        .incoming-call-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .incoming-call-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .incoming-call-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .incoming-call-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .accept-call {
            background: rgba(0, 200, 0, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
        }

        .reject-call {
            background: rgba(200, 0, 0, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
        }

        /* Glow effects */
        @keyframes glow-violet {
            0% { box-shadow: 0 0 5px rgba(120, 80, 200, 0.7); }
            50% { box-shadow: 0 0 20px rgba(120, 80, 200, 0.9); }
            100% { box-shadow: 0 0 5px rgba(120, 80, 200, 0.7); }
        }

        @keyframes glow-sapphire {
            0% { box-shadow: 0 0 5px rgba(0, 100, 200, 0.7); }
            50% { box-shadow: 0 0 20px rgba(0, 100, 200, 0.9); }
            100% { box-shadow: 0 0 5px rgba(0, 100, 200, 0.7); }
        }

        @keyframes glow-red {
            0% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.7); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.9); }
            100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.7); }
        }

        @keyframes glow-green {
            0% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.7); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.9); }
            100% { box-shadow: 0 0 5px rgba(0, 255, 0, 0.7); }
        }

        .glow-violet { animation: glow-violet 2s infinite; }
        .glow-sapphire { animation: glow-sapphire 2s infinite; }
        .glow-red { animation: glow-red 2s infinite; }
        .glow-green { animation: glow-green 2s infinite; }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes messageAppear {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .glass-container {
                width: 100vw;
                height: 100vh;
                margin: 0;
                border-radius: 0;
            }
            
            .header-right {
                gap: 8px;
            }
            
            .header-btn {
                width: 36px;
                height: 36px;
                font-size: 12px;
            }
            
            .video-box {
                width: 95vw;
            }
            
            .video-call-container {
                width: 85vw;
                height: 60vh;
            }
            
            .local-video-container {
                width: 30vw;
                height: 20vh;
            }
            
            .message {
                max-width: 85%;
            }
        }
    </style>
</head>
<body>
    <!-- Gradient background sets -->
    <div class="gradient-bg">
        <!-- Stage 1: Violet (Mystical & Elegant) -->
        <div class="gradient-set" id="set1">
            <div class="gradient" style="background: linear-gradient(135deg, rgba(48,0,72,0.8), rgba(25,0,51,0.9), rgba(10,0,20,1));"></div>
            <div class="gradient-2" style="background: linear-gradient(45deg, rgba(48,0,72,0.8), rgba(25,0,51,0.9), rgba(10,0,20,1));"></div>
            <div class="gradient-3" style="background: linear-gradient(225deg, rgba(48,0,72,0.8), rgba(25,0,51,0.9), rgba(10,0,20,1));"></div>
        </div>
        <!-- Stage 2: Violet-Sapphire Blend (Shares Violet with Stage 1) -->
        <div class="gradient-set" id="set2">
            <div class="gradient" style="background: linear-gradient(135deg, rgba(48,0,72,0.8), rgba(20,40,90,0.9), rgba(0,10,30,1));"></div>
            <div class="gradient-2" style="background: linear-gradient(45deg, rgba(48,0,72,0.8), rgba(20,40,90,0.9), rgba(0,10,30,1));"></div>
            <div class="gradient-3" style="background: linear-gradient(225deg, rgba(48,0,72,0.8), rgba(20,40,90,0.9), rgba(0,10,30,1));"></div>
        </div>
        <!-- Stage 3: Sapphire-Violet with Near Black (Depth & Dreamlike) -->
        <div class="gradient-set" id="set3">
            <div class="gradient" style="background: linear-gradient(135deg, rgba(20,40,90,0.8), rgba(48,0,72,0.7), rgba(5,5,10,1));"></div>
            <div class="gradient-2" style="background: linear-gradient(45deg, rgba(20,40,90,0.8), rgba(48,0,72,0.7), rgba(5,5,10,1));"></div>
            <div class="gradient-3" style="background: linear-gradient(225deg, rgba(20,40,90,0.8), rgba(48,0,72,0.7), rgba(5,5,10,1));"></div>
        </div>
    </div>

    <!-- Glass container with premium chat UI -->
    <div class="glass-container">
        <div class="chat-header">
            <div class="header-left">
                <div class="chat-title">GEMINI CHAT</div>
                <div class="user-info">
                    <span class="username" id="usernameDisplay">@Username</span>
                    <div class="connection-indicator" id="connectionIndicator"></div>
                </div>
                <div class="typing-indicator" id="typingIndicator"></div>
            </div>
            <div class="header-right">
                <button class="header-btn" id="streamBtn"><i class="fas fa-broadcast-tower"></i></button>
                <button class="header-btn" id="videoCallBtn"><i class="fas fa-video"></i></button>
                <button class="header-btn" id="connectionBtn"><i class="fas fa-plug"></i></button>
                <button class="header-btn" id="fullscreenBtn"><i class="fas fa-expand"></i></button>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message bot">
                Welcome to Gemini Chat! Set your username, exchange your ID and connect to a peer to start chatting.
                <div class="timestamp" id="currentTime"></div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <input type="text" class="chat-input" placeholder="Type a message..." id="messageInput" disabled>
            <div class="input-buttons">
                <button class="input-btn attach-btn" id="attachBtn"><i class="fas fa-paperclip"></i></button>
                <button class="input-btn send-btn" id="sendBtn" disabled><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Stream Modal -->
    <div class="modal" id="streamModal">
        <div class="modal-header">
            <div class="modal-title">Stream Controls</div>
            <div class="modal-header-right">
                <button class="modal-fullscreen-btn" data-modal="streamModal">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="modal-close" id="streamModalClose"><i class="fas fa-arrow-left"></i></button>
            </div>
        </div>
        <div class="modal-content">
            <div class="stream-controls">
                <input type="file" id="streamFileInput" class="file-input" accept="video/*">
                <button class="modal-btn" id="chooseFileBtn">
                    <i class="fas fa-folder-open"></i> Choose Video File
                </button>
                <div class="selected-file-info" id="selectedFileInfo">No file selected</div>
                <div class="stream-buttons">
                    <button class="modal-btn" id="startStreamBtn" disabled><i class="fas fa-play"></i> Start Stream</button>
                    <button class="modal-btn" id="stopStreamBtn" disabled><i class="fas fa-stop"></i> Stop Stream</button>
                </div>
            </div>
            <div class="video-container">
                <div class="video-box">
                    <div class="video-title">Local Stream</div>
                    <div class="video-wrapper">
                        <video id="localStreamVideo" class="stream-video" controls></video>
                    </div>
                </div>
                <div class="video-box">
                    <div class="video-title">Remote Stream</div>
                    <div class="video-wrapper">
                        <video id="remoteStreamVideo" class="stream-video" controls autoplay playsinline></video>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Video Call Modal -->
    <div class="modal" id="videoCallModal">
        <div class="modal-header">
            <div class="modal-title">Video Call</div>
            <div class="modal-header-right">
                <button class="modal-fullscreen-btn" data-modal="videoCallModal">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="modal-close" id="videoCallModalClose"><i class="fas fa-arrow-left"></i></button>
            </div>
        </div>
        <div class="modal-content">
            <div class="modal-actions">
                <button class="modal-btn" id="startVideoCallBtn"><i class="fas fa-video"></i> Start Video Call</button>
                <button class="modal-btn" id="startVoiceCallBtn"><i class="fas fa-phone"></i> Start Voice Call</button>
                <button class="modal-btn" id="endCallBtn" disabled><i class="fas fa-phone-slash"></i> End Call</button>
            </div>
            
            <div class="video-call-container">
                <video class="remote-video" id="remoteVideo" autoplay playsinline></video>
                <div class="local-video-container">
                    <video class="local-video" id="localVideo" muted autoplay playsinline></video>
                </div>
            </div>
        </div>
    </div>

    <!-- Connection Modal -->
    <div class="modal" id="connectionModal">
        <div class="modal-header">
            <div class="modal-title">Connection Settings</div>
            <div class="modal-header-right">
                <button class="modal-fullscreen-btn" data-modal="connectionModal">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="modal-close" id="connectionModalClose"><i class="fas fa-arrow-left"></i></button>
            </div>
        </div>
        <div class="modal-content">
            <div class="form-group">
                <label>Username</label>
                <input type="text" class="form-control" id="usernameInput" placeholder="Enter username">
                <button class="modal-btn save-btn" id="saveUsernameBtn"><i class="fas fa-save"></i> Save Username</button>
            </div>
            <div class="form-group">
                <label>Your ID</label>
                <input type="text" class="form-control" id="myIdInput" value="Generating..." readonly>
                <button class="modal-btn" id="copyIdBtn" style="margin-top: 8px;"><i class="fas fa-copy"></i> Copy ID</button>
            </div>
            <div class="form-group">
                <label>Connect to ID</label>
                <input type="text" class="form-control" id="peerIdInput" placeholder="Enter connection ID">
                <button class="modal-btn" id="connectToPeerBtn" style="margin-top: 8px;"><i class="fas fa-link"></i> Connect</button>
            </div>
            <div class="connection-status">
                Status: <span id="connectionStatusText">Disconnected</span>
            </div>
            <div class="developer-credit">Developed by Jijo</div>
        </div>
    </div>

    <!-- Files Modal -->
    <div class="modal" id="filesModal">
        <div class="modal-header">
            <div class="modal-title">Share Files</div>
            <div class="modal-header-right">
                <button class="modal-fullscreen-btn" data-modal="filesModal">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="modal-close" id="filesModalClose"><i class="fas fa-arrow-left"></i></button>
            </div>
        </div>
        <div class="modal-content">
            <div class="modal-actions">
                <input type="file" id="downloadableFileInput" class="file-input" multiple>
                <button class="modal-btn" id="shareDownloadableBtn">
                    <i class="fas fa-download"></i> Share Downloadable Files
                </button>
                
                <input type="file" id="nonDownloadableFileInput" class="file-input" accept="image/*,video/*" multiple>
                <button class="modal-btn" id="shareNonDownloadableBtn">
                    <i class="fas fa-file"></i> Share Non-Downloadable Files
                </button>
            </div>
            <h3 style="margin-top: 20px; width: 100%;">Transfers & Received Files</h3>
            <div class="transfer-list" id="transferList">
                <div class="transfer-item">No active transfers</div>
            </div>
        </div>
    </div>

    <!-- File Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-content" id="previewContent">
            <!-- Content will be filled dynamically -->
        </div>
        <button class="back-btn" id="previewBackBtn">Back</button>
    </div>

    <!-- Incoming Call Modal -->
    <div class="incoming-call-modal" id="incomingCallModal">
        <div class="incoming-call-content">
            <h2>Incoming Call</h2>
            <p id="incomingCallText">is calling you</p>
            <div class="incoming-call-buttons">
                <button class="accept-call" id="acceptCallBtn">Accept</button>
                <button class="reject-call" id="rejectCallBtn">Reject</button>
            </div>
        </div>
    </div>

    <script>
        // ======================= WebRTC Configuration =======================
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        // WebRTC Variables
        let peer, connection, dataChannel;
        let localStream = null, remoteStream = null;
        let mediaCall = null, streamCall = null;
        let isCaller = false, connectedPeerId = null, typingTimer = null;
        let capturedMediaStream = null;
        let myUsername = '';
        let peerUsername = '';
        let incomingCall = null;
        let connectionStatus = 'disconnected';
        let newMessageInModal = false;

        // File transfer (256KB chunks - optimized)
        const CHUNK_SIZE = 256 * 1024;
        const sendingTransfers = new Map();
        const receivingTransfers = new Map();

        // DOM Elements
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const attachBtn = document.getElementById('attachBtn');
        const streamBtn = document.getElementById('streamBtn');
        const videoCallBtn = document.getElementById('videoCallBtn');
        const connectionBtn = document.getElementById('connectionBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const streamModal = document.getElementById('streamModal');
        const videoCallModal = document.getElementById('videoCallModal');
        const connectionModal = document.getElementById('connectionModal');
        const filesModal = document.getElementById('filesModal');
        const glassContainer = document.querySelector('.glass-container');
        const modalCloseButtons = document.querySelectorAll('.modal-close');
        const typingIndicator = document.getElementById('typingIndicator');
        const remoteVideo = document.getElementById('remoteVideo');
        const localVideo = document.getElementById('localVideo');
        const modalFullscreenButtons = document.querySelectorAll('.modal-fullscreen-btn');
        const usernameInput = document.getElementById('usernameInput');
        const usernameDisplay = document.getElementById('usernameDisplay');
        const saveUsernameBtn = document.getElementById('saveUsernameBtn');
        const chooseFileBtn = document.getElementById('chooseFileBtn');
        const streamFileInput = document.getElementById('streamFileInput');
        const startStreamBtn = document.getElementById('startStreamBtn');
        const stopStreamBtn = document.getElementById('stopStreamBtn');
        const localStreamVideo = document.getElementById('localStreamVideo');
        const remoteStreamVideo = document.getElementById('remoteStreamVideo');
        const selectedFileInfo = document.getElementById('selectedFileInfo');
        const myIdInput = document.getElementById('myIdInput');
        const copyIdBtn = document.getElementById('copyIdBtn');
        const peerIdInput = document.getElementById('peerIdInput');
        const connectToPeerBtn = document.getElementById('connectToPeerBtn');
        const connectionStatusText = document.getElementById('connectionStatusText');
        const connectionIndicator = document.getElementById('connectionIndicator');
        const startVideoCallBtn = document.getElementById('startVideoCallBtn');
        const startVoiceCallBtn = document.getElementById('startVoiceCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const shareDownloadableBtn = document.getElementById('shareDownloadableBtn');
        const shareNonDownloadableBtn = document.getElementById('shareNonDownloadableBtn');
        const downloadableFileInput = document.getElementById('downloadableFileInput');
        const nonDownloadableFileInput = document.getElementById('nonDownloadableFileInput');
        const transferList = document.getElementById('transferList');
        const previewModal = document.getElementById('previewModal');
        const previewContent = document.getElementById('previewContent');
        const previewBackBtn = document.getElementById('previewBackBtn');
        const incomingCallModal = document.getElementById('incomingCallModal');
        const incomingCallText = document.getElementById('incomingCallText');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const rejectCallBtn = document.getElementById('rejectCallBtn');
        const streamModalClose = document.getElementById('streamModalClose');
        const videoCallModalClose = document.getElementById('videoCallModalClose');
        const connectionModalClose = document.getElementById('connectionModalClose');
        const filesModalClose = document.getElementById('filesModalClose');

        // Initialize
        function init() {
            // Start gradient animation
            cycleColors();
            
            // Hide typing indicator initially
            typingIndicator.style.display = 'none';
            
            // Remove controls from video call elements
            remoteVideo.removeAttribute('controls');
            localVideo.removeAttribute('controls');
            
            // Set current time for welcome message
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            document.getElementById('currentTime').textContent = timeString;
            
            // Load saved username
            loadUsername();
            
            // Setup event listeners
            setupEventListeners();
            
            // Initialize PeerJS
            initializePeer();
            
            // Set initial button states
            updateButtonGlows();
        }

        // Update button glow states
        function updateButtonGlows() {
            // Fullscreen button glow
            if (!document.fullscreenElement) {
                fullscreenBtn.classList.add('glow-violet');
            } else {
                fullscreenBtn.classList.remove('glow-violet');
            }
            
            // Connection button glow
            if (connectionStatus === 'disconnected' || connectionStatus === 'error') {
                connectionBtn.classList.add('glow-red');
            } else {
                connectionBtn.classList.remove('glow-red');
            }
        }

        // Initialize PeerJS
        function initializePeer() {
            peer = new Peer({ config, debug: 2 });

            peer.on('open', id => {
                myIdInput.value = id;
                updateConnectionStatus('disconnected', 'Ready to connect');
                copyIdBtn.disabled = false;
            });

            peer.on('connection', conn => {
                if (connection && connection.open) { 
                    conn.close(); 
                    return; 
                }
                connectedPeerId = conn.peer;
                setupDataConnection(conn);
                peerIdInput.value = conn.peer;
                connectToPeerBtn.disabled = true;
            });

            // Incoming calls
            peer.on('call', call => {
                const callType = call.metadata && call.metadata.type ? call.metadata.type : 'media';
                
                if (callType === 'stream') {
                    // Automatically accept stream calls without showing incoming call modal
                    call.answer(null); // No media stream needed for receiving stream
                    streamCall = call;
                    setupMediaCallHandlers(call, 'stream');
                    
                    // Open stream modal automatically
                    streamModal.classList.add('active');
                    // Make stream button stop glowing
                    streamBtn.classList.remove('glow-sapphire');
                } else {
                    // For regular calls, show incoming call modal
                    incomingCall = call;
                    incomingCallText.textContent = `${peerUsername || 'Peer'} is calling you`;
                    incomingCallModal.classList.add('active');
                    
                    // Make video call button glow
                    videoCallBtn.classList.add('glow-sapphire');

                    // Set up accept/reject handlers
                    acceptCallBtn.onclick = () => {
                        try {
                            if (callType === 'media') {
                                if (streamCall) {
                                    try { streamCall.close(); } catch(e) {}
                                    streamCall = null;
                                    stopCapturedMediaStream();
                                }
                                call.answer(localStream || undefined);
                                mediaCall = call;
                                setupMediaCallHandlers(call, 'media');
                            }
                            incomingCallModal.classList.remove('active');
                            videoCallModal.classList.add('active');
                            // Stop video call button glow
                            videoCallBtn.classList.remove('glow-sapphire');
                        } catch (err) {
                            console.error('Error answering call:', err);
                            updateConnectionStatus('error', 'Call answer failed');
                        }
                    };

                    rejectCallBtn.onclick = () => {
                        call.close();
                        incomingCallModal.classList.remove('active');
                        // Stop video call button glow
                        videoCallBtn.classList.remove('glow-sapphire');
                    };
                }
            });

            peer.on('disconnected', () => {
                updateConnectionStatus('disconnected', 'Peer disconnected');
                resetConnectionState();
            });

            peer.on('error', err => {
                console.error('PeerJS error:', err);
                updateConnectionStatus('error', 'Error: ' + (err && err.type ? err.type : err));
            });
        }

        // Update connection status
        function updateConnectionStatus(state, message) {
            connectionStatus = state;
            connectionStatusText.textContent = message;
            
            // Update connection indicator
            connectionIndicator.classList.remove('connected', 'unavailable');
            
            if (state === 'connected') {
                connectionIndicator.classList.add('connected');
                connectionStatusText.style.color = '#00ff00';
            } else if (state === 'connecting' || state === 'unavailable') {
                connectionIndicator.classList.add('unavailable');
                connectionStatusText.style.color = '#ff9500';
            } else {
                connectionStatusText.style.color = '#ff3b30';
            }
            
            // Update button glows
            updateButtonGlows();
        }

        // Setup data connection
        function setupDataConnection(conn) {
            connection = conn;
            connection.on('open', () => {
                dataChannel = connection;
                updateConnectionStatus('connected', 'Connected to ' + connection.peer);
                messageInput.disabled = false;
                sendBtn.disabled = false;
                startStreamBtn.disabled = false;
                connectedPeerId = connection.peer;

                // Send our username to the peer
                if (myUsername) {
                    dataChannel.send({ type: 'username', username: myUsername });
                }
                
                // Close connection modal automatically
                connectionModal.classList.remove('active');
                
                setupDataChannel();
            });
            connection.on('close', () => {
                updateConnectionStatus('disconnected', 'Connection closed');
                resetConnectionState();
            });
            connection.on('error', err => {
                console.error('Connection error:', err);
                updateConnectionStatus('error', 'Connection error');
            });
            
            // Check for temporary connection issues
            connection.on('iceStateChanged', state => {
                if (state === 'disconnected' || state === 'failed') {
                    updateConnectionStatus('unavailable', 'Connection unstable');
                } else if (state === 'connected') {
                    updateConnectionStatus('connected', 'Connected to ' + connection.peer);
                }
            });
        }

        function setupDataChannel() {
            if (!dataChannel) return;
            dataChannel.on('data', handleDataMessage);
            try {
                if (dataChannel._dc) dataChannel._dc.binaryType = 'arraybuffer';
            } catch(e){}
        }

        // Handle incoming data messages
        function handleDataMessage(data) {
            if (!data) return;
            try {
                switch(data.type){
                    case 'chat':
                        addMessage(data.message, 'remote');
                        
                        // If a modal is open, make its close button glow
                        const activeModal = document.querySelector('.modal.active');
                        if (activeModal) {
                            const closeBtn = activeModal.querySelector('.modal-close');
                            if (closeBtn) {
                                closeBtn.classList.add('glow-green');
                                newMessageInModal = true;
                            }
                        }
                        break;
                    case 'typing-start':
                        if (data.message) {
                            typingIndicator.textContent = data.message;
                        } else {
                            typingIndicator.textContent = `${peerUsername || 'Peer'} is typing`;
                        }
                        typingIndicator.style.display = 'block';
                        break;
                    case 'typing-stop':
                        typingIndicator.style.display = 'none';
                        break;
                    case 'username':
                        // Store peer's username
                        peerUsername = data.username;
                        usernameDisplay.textContent = `@${peerUsername}`;
                        updateConnectionStatus('connected', `Connected to ${peerUsername}`);
                        break;
                    case 'file-selecting':
                        typingIndicator.textContent = `${peerUsername || 'Peer'} is choosing file for ${data.purpose}`;
                        typingIndicator.style.display = 'block';
                        break;
                    /* File transfer protocol */
                    case 'file-meta':
                        startReceivingFile(data.meta);
                        // Make files button glow
                        attachBtn.classList.add('glow-sapphire');
                        break;
                    case 'file-chunk':
                        receiveFileChunk(data.id, data.seq, data.total, data.chunk);
                        break;
                    case 'file-complete':
                        finalizeReceivedFile(data.id);
                        // Open files modal automatically when file is received
                        filesModal.classList.add('active');
                        // Stop files button glow
                        attachBtn.classList.remove('glow-sapphire');
                        break;
                    case 'file-progress':
                        updateSendProgressUI(data.id, data.percent);
                        break;
                    case 'stream-started':
                        // Make stream button glow
                        streamBtn.classList.add('glow-sapphire');
                        break;
                    default:
                        // ignore
                        break;
                }
            } catch (err) {
                console.error('Error handling data message', err);
            }
        }

        // Load username from localStorage
        function loadUsername() {
            const savedUsername = localStorage.getItem('geminiChatUsername');
            if (savedUsername) {
                usernameInput.value = savedUsername;
                myUsername = savedUsername;
                usernameDisplay.textContent = `@${savedUsername}`;
            }
        }

        // Save username to localStorage
        function saveUsername() {
            const username = usernameInput.value.trim();
            if (username) {
                localStorage.setItem('geminiChatUsername', username);
                myUsername = username;
                usernameDisplay.textContent = `@${username}`;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Save username button
            saveUsernameBtn.addEventListener('click', saveUsername);
            
            // Choose file button
            chooseFileBtn.addEventListener('click', () => {
                streamFileInput.click();
                // Notify peer that we're selecting a file
                if (dataChannel) {
                    dataChannel.send({ type: 'file-selecting', purpose: 'streaming' });
                }
            });
            
            // File selection
            streamFileInput.addEventListener('change', handleFileSelection);
            
            // Start stream button
            startStreamBtn.addEventListener('click', startStreaming);
            
            // Stop stream button
            stopStreamBtn.addEventListener('click', stopStreaming);
            
            // Copy ID button
            copyIdBtn.addEventListener('click', copyIdToClipboard);
            
            // Connect to peer button
            connectToPeerBtn.addEventListener('click', connectToPeer);
            
            // Start video call button
            startVideoCallBtn.addEventListener('click', startVideoCall);
            
            // Start voice call button
            startVoiceCallBtn.addEventListener('click', startVoiceCall);
            
            // End call button
            endCallBtn.addEventListener('click', endCall);
            
            // Share downloadable files
            shareDownloadableBtn.addEventListener('click', () => {
                downloadableFileInput.click();
                // Notify peer that we're selecting a file
                if (dataChannel) {
                    dataChannel.send({ type: 'file-selecting', purpose: 'file transfer' });
                }
            });
            
            // Share non-downloadable files
            shareNonDownloadableBtn.addEventListener('click', () => {
                nonDownloadableFileInput.click();
                // Notify peer that we're selecting a file
                if (dataChannel) {
                    dataChannel.send({ type: 'file-selecting', purpose: 'file transfer' });
                }
            });
            
            // File input handlers
            downloadableFileInput.addEventListener('change', handleDownloadableFileSelect);
            nonDownloadableFileInput.addEventListener('change', handleNonDownloadableFileSelect);
            
            // Send message
            sendBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Typing indicator
            messageInput.addEventListener('input', handleTyping);
            
            // Modal buttons
            streamBtn.addEventListener('click', () => {
                streamModal.classList.add('active');
                // Stop stream button glow
                streamBtn.classList.remove('glow-sapphire');
            });

            videoCallBtn.addEventListener('click', () => {
                videoCallModal.classList.add('active');
                // Stop video call button glow
                videoCallBtn.classList.remove('glow-sapphire');
            });

            connectionBtn.addEventListener('click', () => {
                connectionModal.classList.add('active');
                // Stop connection button glow
                connectionBtn.classList.remove('glow-red');
            });

            attachBtn.addEventListener('click', () => {
                filesModal.classList.add('active');
                // Stop files button glow
                attachBtn.classList.remove('glow-sapphire');
            });

            // Close modals
            modalCloseButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.modal').forEach(modal => {
                        modal.classList.remove('active');
                    });
                    // Remove glow from close button
                    e.currentTarget.classList.remove('glow-green');
                    newMessageInModal = false;
                });
            });

            // Preview back button
            previewBackBtn.addEventListener('click', () => {
                previewModal.classList.remove('active');
                // Stop video if playing
                const video = previewContent.querySelector('video');
                if (video) {
                    video.pause();
                }
            });

            // Fullscreen functionality
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });

            // Listen for fullscreen changes
            document.addEventListener('fullscreenchange', () => {
                updateButtonGlows();
            });

            // Modal fullscreen functionality
            modalFullscreenButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modalId = e.currentTarget.getAttribute('data-modal');
                    const modal = document.getElementById(modalId);
                    
                    if (!document.fullscreenElement) {
                        modal.requestFullscreen().catch(err => {
                            console.error(`Error attempting to enable fullscreen: ${err.message}`);
                        });
                    } else {
                        document.exitFullscreen();
                    }
                });
            });

            // Adjust container height for mobile keyboard
            messageInput.addEventListener('focus', () => {
                if (window.innerWidth < 768) {
                    glassContainer.style.height = '60vh';
                }
            });

            messageInput.addEventListener('blur', () => {
                // Don't reset height if a modal is open
                if (window.innerWidth < 768 && !document.querySelector('.modal.active')) {
                    glassContainer.style.height = '100vh';
                }
            });
        }

        // Handle file selection for streaming
        function handleFileSelection(e) {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                selectedFileInfo.textContent = `Selected: ${file.name}`;
                startStreamBtn.disabled = false;
                
                // Create object URL for preview
                const fileURL = URL.createObjectURL(file);
                localStreamVideo.src = fileURL;
                
                // Stop typing indicator
                if (dataChannel) {
                    dataChannel.send({ type: 'typing-stop' });
                }
            }
        }

        // Start streaming
        async function startStreaming() {
            if (!connection) {
                return;
            }
            
            const file = streamFileInput.files[0];
            if (!file) {
                return;
            }

            try {
                const fileURL = URL.createObjectURL(file);
                localStreamVideo.src = fileURL;
                
                localStreamVideo.onloadedmetadata = async () => {
                    try {
                        await localStreamVideo.play();
                    } catch(e){}

                    if (!localStreamVideo.captureStream) { 
                        return;
                    }
                    
                    try {
                        stopCapturedMediaStream();
                        capturedMediaStream = localStreamVideo.captureStream();
                        
                        const call = peer.call(connection.peer, capturedMediaStream, { metadata: { type: 'stream' } });
                        streamCall = call;
                        setupMediaCallHandlers(call, 'stream');
                        
                        call.on('stream', rStream => {
                            remoteStreamVideo.srcObject = rStream;
                            remoteStreamVideo.play().catch(() => {});
                            // Notify peer that streaming has started
                            dataChannel.send({ type: 'stream-started' });

                            // Apply bandwidth prioritization for file streaming too
                            prioritizeBandwidth(call.peerConnection, 'video');
                            prioritizeBandwidth(call.peerConnection, 'audio');
                        });
                        
                        call.on('close', stopStreaming);
                        
                        startStreamBtn.disabled = true;
                        stopStreamBtn.disabled = false;
                    } catch (err) {
                        console.error('Start stream error', err);
                        stopCapturedMediaStream();
                    }
                };
            } catch (err) {
                console.error('Stream error:', err);
            }
        }

        // Stop streaming
        function stopStreaming() {
            if (streamCall) {
                try{ streamCall.close(); } catch(e){}
                streamCall = null;
            }
            stopCapturedMediaStream();
            try { localStreamVideo.pause(); } catch(e){}
            localStreamVideo.src = '';
            remoteStreamVideo.srcObject = null;
            startStreamBtn.disabled = false;
            stopStreamBtn.disabled = true;
        }

        function stopCapturedMediaStream() {
            if (capturedMediaStream) {
                try { capturedMediaStream.getTracks().forEach(t=>t.stop()); } catch(e){}
                capturedMediaStream = null;
            }
        }

        // Copy ID to clipboard
        function copyIdToClipboard() {
            const id = myIdInput.value;
            navigator.clipboard.writeText(id).then(() => {
                // No longer adding chat message for this action
            });
        }

        // Connect to peer
        function connectToPeer() {
            const peerId = peerIdInput.value.trim();
            if (!peerId) {
                return;
            }
            if (!myUsername) {
                return;
            }
            
            updateConnectionStatus('connecting', 'Connecting to ' + peerId);
            connectedPeerId = peerId;
            const conn = peer.connect(peerId, { reliable: true });
            setupDataConnection(conn);
            connectToPeerBtn.disabled = true;
        }

        // Start video call
        async function startVideoCall() {
            try {
                if (streamCall) {
                    try { streamCall.close(); } catch(e){}
                    streamCall = null;
                    stopCapturedMediaStream();
                }

                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1920 }, 
                        height: { ideal: 1080 }, 
                        frameRate: { ideal: 60, max: 60 } 
                    },
                    audio: true
                });
                localVideo.srcObject = localStream;
                startCall('media');
                endCallBtn.disabled = false;
            } catch(e) { 
                console.error(e);
            }
        }

        // Start voice call
        async function startVoiceCall() {
            try {
                if (streamCall) {
                    try { streamCall.close(); } catch(e){}
                    streamCall = null;
                    stopCapturedMediaStream();
                }

                localStream = await navigator.mediaDevices.getUserMedia({video:false, audio:true});
                startCall('media');
                endCallBtn.disabled = false;
            } catch(e) { 
                console.error(e);
            }
        }

        function startCall(type='media') {
            if (!connection) {
                return;
            }
            
            isCaller = true;

            if (mediaCall) {
                try { mediaCall.close(); } catch(e){}
                mediaCall = null;
            }

            const call = peer.call(connection.peer, localStream, { metadata: { type: type === 'stream' ? 'stream' : 'media' } });
            mediaCall = call;
            setupMediaCallHandlers(call, 'media');

            call.on('stream', () => {
                prioritizeBandwidth(call.peerConnection, 'video');
                prioritizeBandwidth(call.peerConnection, 'audio');
            });

            call.on('error', err => {
                console.error('Call error:', err);
                updateConnectionStatus('error', 'Media error');
            });
        }

        function setupMediaCallHandlers(call, kind = 'media') {
            call.on('stream', stream => {
                if (kind === 'media') {
                    remoteStream = stream;
                    remoteVideo.srcObject = stream;
                } else if (kind === 'stream') {
                    remoteStreamVideo.srcObject = stream;
                }
            });

            call.on('close', () => {
                if (kind === 'media') {
                    endCall();
                } else if (kind === 'stream') {
                    stopStreaming();
                }
            });

            call.on('error', err => {
                console.error(kind + ' call error:', err);
                updateConnectionStatus('error', `${kind} media error`);
                if (kind === 'media') endCall();
                else stopStreaming();
            });
        }

        function prioritizeBandwidth(pc, kind = 'video') {
            if (!pc) return;
            try {
                const senders = pc.getSenders ? pc.getSenders() : [];
                senders.forEach(sender => {
                    if (!sender || !sender.track) return;
                    const trackKind = sender.track.kind;
                    if ((kind === 'video' && trackKind === 'video') || (kind === 'audio' && trackKind === 'audio')) {
                        const params = sender.getParameters ? sender.getParameters() : null;
                        if (params && params.encodings && params.encodings.length) {
                            params.encodings.forEach(enc => {
                                if (trackKind === 'video') {
                                    // Adaptive video bitrate (1 Mbps → 5 Mbps)
                                    enc.minBitrate = 1_000_000;   // fallback for weak networks
                                    enc.maxBitrate = 5_000_000;   // cap for strong networks
                                    enc.priority = 'high';
                                } else if (trackKind === 'audio') {
                                    // Adaptive audio bitrate (32 kbps → 128 kbps)
                                    enc.minBitrate = 32_000;
                                    enc.maxBitrate = 128_000;
                                    enc.priority = 'high';
                                }
                            });
                            try {
                                sender.setParameters(params).catch(()=>{});
                            } catch(e){}
                        }
                    }
                });
            } catch (e) {
                console.warn('Adaptive bandwidth prioritization not fully supported by browser', e);
            }
        }

        // End call
        function endCall() {
            if (mediaCall) {
                try{ mediaCall.close(); } catch(e){}
                mediaCall = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
                localVideo.srcObject = null;
            }
            if (remoteStream) {
                try{ remoteStream.getTracks().forEach(t=>t.stop()); } catch(e){}
                remoteStream = null;
                remoteVideo.srcObject = null;
            }
            endCallBtn.disabled = true;
            videoCallModal.classList.remove('active');
        }

        // Handle downloadable file selection
        function handleDownloadableFileSelect(e) {
            if (!dataChannel) {
                return;
            }
            
            const files = Array.from(e.target.files || []);
            files.forEach(f => sendFileAsChunks(f, 'downloadable'));
            e.target.value = '';
            
            // Stop typing indicator
            if (dataChannel) {
                dataChannel.send({ type: 'typing-stop' });
            }
        }

        // Handle non-downloadable file selection
        function handleNonDownloadableFileSelect(e) {
            if (!dataChannel) {
                return;
            }
            
            const files = Array.from(e.target.files || []);
            files.forEach(f => sendFileAsChunks(f, 'non-downloadable'));
            e.target.value = '';
            
            // Stop typing indicator
            if (dataChannel) {
                dataChannel.send({ type: 'typing-stop' });
            }
        }

        // File transfer functions
        function uuid() {
            return 'f-' + Math.random().toString(36).slice(2) + '-' + Date.now().toString(36);
        }

        function humanSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes/1024).toFixed(1) + ' KB';
            return (bytes/1048576).toFixed(1) + ' MB';
        }

        function createTransferUI(id, name, size, type) {
            const wrap = document.createElement('div');
            wrap.className = 'transfer-item';
            wrap.id = `xfer-${id}`;

            const top = document.createElement('div');
            top.className = 'transfer-top';

            const nameEl = document.createElement('div');
            nameEl.className = 'transfer-name';
            nameEl.textContent = `${name} (${humanSize(size)})`;
            top.appendChild(nameEl);

            const pctEl = document.createElement('div');
            pctEl.id = `pct-${id}`;
            pctEl.textContent = '0%';
            top.appendChild(pctEl);

            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            const prog = document.createElement('div');
            prog.className = 'progress';
            prog.dataset.type = type;
            prog.style.width = '0%';
            bar.appendChild(prog);

            wrap.appendChild(top);
            wrap.appendChild(bar);

            // Clear "no active transfers" message if it exists
            if (transferList.children.length === 1 && 
                transferList.children[0].textContent === 'No active transfers') {
                transferList.innerHTML = '';
            }
            
            transferList.appendChild(wrap);
            return {wrap, pctEl, prog};
        }

        function updateProgressUI(id, percent) {
            const pctEl = document.getElementById(`pct-${id}`);
            const prog = document.querySelector(`#xfer-${id} .progress`);
            if (pctEl) pctEl.textContent = `${percent}%`;
            if (prog) prog.style.width = `${percent}%`;
        }

        function wait(ms) { 
            return new Promise(r => setTimeout(r, ms)); 
        }

        async function sendFileAsChunks(file, category) {
            const id = uuid();
            const meta = { id, name: file.name, size: file.size, mime: file.type || 'application/octet-stream', category };
            const ui = createTransferUI(id, file.name, file.size, 'send');

            sendingTransfers.set(id, { file, offset: 0, total: file.size, name: file.name, size: file.size, mime: meta.mime, category, ui });

            try { 
                dataChannel.send({ type: 'file-meta', meta }); 
            } catch(e) { 
                console.error('send meta failed', e); 
            }

            const reader = new FileReader();
            let offset = 0;
            let seq = 0;
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

            function readSlice(o) { 
                const slice = file.slice(o, Math.min(o + CHUNK_SIZE, file.size)); 
                reader.readAsArrayBuffer(slice); 
            }

            reader.onload = async () => {
                const chunk = reader.result;
                try {
                    dataChannel.send({ type:'file-chunk', id, seq, total: totalChunks, chunk });
                } catch (err) {
                    try {
                        const blob = new Blob([chunk]);
                        const text = await blobToBase64(blob);
                        dataChannel.send({ type:'file-chunk', id, seq, total: totalChunks, chunkB64: text });
                    } catch(e) {
                        console.error('Failed to send chunk', e);
                    }
                }

                offset += chunk.byteLength;
                seq += 1;
                
                const percent = Math.min(100, Math.floor((offset / file.size) * 100));
                updateProgressUI(id, percent);
                
                if (offset < file.size) {
                    const adaptiveDelay = Math.min(40, Math.max(8, Math.floor((CHUNK_SIZE / 1024) / 6)));
                    await wait(adaptiveDelay);
                    readSlice(offset);
                } else {
                    try { 
                        dataChannel.send({ type:'file-complete', id }); 
                    } catch(e) { 
                        console.error('send complete err', e); 
                    }
                }
            };

            readSlice(0);
        }

        function blobToBase64(blob) { 
            return new Promise((res, rej) => {
                const r = new FileReader();
                r.onload = () => res(r.result.split(',')[1]);
                r.onerror = rej;
                r.readAsDataURL(blob);
            }); 
        }

        function startReceivingFile(meta) {
            const { id, name, size, category } = meta;
            const ui = createTransferUI(id, name, size, 'recv');
            receivingTransfers.set(id, { chunks: [], received: 0, total: size, totalChunks: Math.ceil(size / CHUNK_SIZE), meta, ui });
        }

        async function receiveFileChunk(id, seq, total, chunk) {
            const rcv = receivingTransfers.get(id);
            if (!rcv) return;

            if (chunk) {
                try {
                    const arr = new Uint8Array(chunk);
                    rcv.chunks[seq] = arr;
                    rcv.received += arr.byteLength;
                } catch (e) {}
            }

            const pct = Math.min(100, Math.floor((rcv.received / rcv.total) * 100));
            updateProgressUI(id, pct);

            try { 
                dataChannel.send({ type: 'file-progress', id, percent: pct }); 
            } catch(e){}

            // Check if we've received all chunks
            const receivedChunks = rcv.chunks.filter(chunk => chunk !== undefined).length;
            if (receivedChunks === rcv.totalChunks || rcv.received >= rcv.total) {
                finalizeReceivedFile(id);
            }
        }

        function updateSendProgressUI(id, percent) {
            updateProgressUI(id, Math.max(0, Math.min(100, Math.floor(percent))));
        }

        async function finalizeReceivedFile(id) {
            const rcv = receivingTransfers.get(id);
            if (!rcv) return;

            // Verify we have all chunks
            const ordered = [];
            for (let i = 0; i < rcv.totalChunks; i++) {
                if (rcv.chunks[i]) {
                    ordered.push(rcv.chunks[i]);
                } else {
                    console.error('Missing chunk:', i, 'for file:', id);
                    return;
                }
            }

            // Check if we have the correct amount of data
            if (rcv.received !== rcv.total) {
                console.error('File size mismatch for:', id, 'Received:', rcv.received, 'Expected:', rcv.total);
                return;
            }

            const blob = new Blob(ordered, { type: rcv.meta.mime });
            const url = URL.createObjectURL(blob);

            const parent = document.getElementById(`xfer-${id}`);
            if (!parent) return;

            const line = document.createElement('div');
            line.style.marginTop = '6px';

            const link = document.createElement('a');
            link.className = 'file-link';
            
            if (rcv.meta.category === 'downloadable') {
                link.textContent = 'Download file';
                link.href = url;
                link.download = rcv.meta.name || 'file';
            } else {
                link.textContent = 'Open preview';
                link.href = 'javascript:void(0)';
                link.addEventListener('click', () => openPreviewModal(rcv.meta.name, url, rcv.meta.mime));
            }

            line.appendChild(link);
            parent.appendChild(line);

            updateProgressUI(id, 100);
            receivingTransfers.delete(id);
        }

        function openPreviewModal(name, url, mime) {
            previewContent.innerHTML = '';
            
            if (mime.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = url;
                img.alt = name;
                previewContent.appendChild(img);
            } else if (mime.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = url;
                video.id = 'previewVideo';
                
                const controls = document.createElement('div');
                controls.className = 'player-controls';
                
                const playBtn = document.createElement('button');
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                playBtn.addEventListener('click', () => {
                    if (video.paused) {
                        video.play();
                        playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    } else {
                        video.pause();
                        playBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                });
                
                const seeker = document.createElement('input');
                seeker.type = 'range';
                seeker.value = 0;
                seeker.addEventListener('input', () => {
                    if (video.duration) {
                        video.currentTime = (seeker.value / 100) * video.duration;
                    }
                });
                
                video.addEventListener('timeupdate', () => {
                    if (video.duration) {
                        seeker.value = (video.currentTime / video.duration) * 100;
                    }
                });
                
                video.addEventListener('ended', () => {
                    playBtn.innerHTML = '<i class="fas fa-play"></i>';
                    seeker.value = 0;
                });
                
                controls.appendChild(playBtn);
                controls.appendChild(seeker);
                
                previewContent.appendChild(video);
                previewContent.appendChild(controls);
            }
            
            previewModal.classList.add('active');
        }

        // Reset connection state
        function resetConnectionState() {
            messageInput.disabled = true;
            sendBtn.disabled = true;
            startStreamBtn.disabled = true;
            stopStreamBtn.disabled = true;
            connectToPeerBtn.disabled = false;
            typingIndicator.style.display = 'none';
            endCall();
            stopStreaming();
            try {
                if (connection && connection.close) connection.close();
            } catch(e){}
            connection = null;
            dataChannel = null;
            connectedPeerId = null;
            peerUsername = '';
            usernameDisplay.textContent = `@${myUsername}`;
            
            // Update button glows
            updateButtonGlows();
        }

        // Add message to chat (only for actual chat messages)
        function addMessage(text, type = 'bot') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type === 'user' ? 'user' : 'bot'}`;
            
            // Get current time for timestamp
            const now = new Date();
            const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                ${text}
                <div class="timestamp">${timeString}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            
            // Animate message
            setTimeout(() => {
                messageDiv.style.animation = 'messageAppear 0.5s forwards';
            }, 10);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Send message
        function sendMessage() {
            const message = messageInput.value.trim();
            if (message && dataChannel) {
                try {
                    dataChannel.send({type:'chat', message});
                    addMessage(message, 'user');
                    messageInput.value = '';
                } catch (err) {
                    console.error('Send message failed', err);
                }
            }
        }

        // Handle typing indicator
        function handleTyping() {
            if (!dataChannel) return;
            try {
                dataChannel.send({type:'typing-start'});
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(() => {
                    dataChannel.send({type:'typing-stop'});
                }, 1000);
            } catch(e){}
        }

        // Gradient animation
        const sets = document.querySelectorAll('.gradient-set');
        let index = 0;

        function cycleColors() {
            const current = sets[index];
            const next = sets[(index + 1) % sets.length];

            current.style.opacity = "1";
            next.style.opacity = "0";

            setTimeout(() => {
                current.style.opacity = "0";
                next.style.opacity = "1";
                index = (index + 1) % sets.length;
                setTimeout(cycleColors, 5000);
            }, 30000);
        }

        // Initialize the app
        init();
    </script>
</body>
</html>
