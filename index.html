<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GEMINI CHAT AND SHARE</title>
  <style>
    /* Dark Theme Global Styles */
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: relative;
      min-height: 100vh;
    }
    h1 {
      margin-bottom: 20px;
    }
    /* Dark themed buttons, inputs and textareas */
    button, input, textarea {
      border-radius: 5px;
      margin: 5px;
      padding: 5px;
      background-color: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    /* Glow effects */
    .glow-green { box-shadow: 0 0 8px 2px green !important; }
    .glow-blue { box-shadow: 0 0 8px 2px blue !important; }
    .glow-red { box-shadow: 0 0 8px 2px red !important; }
    
    /* Main Tabs styling */
    #mainTabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      width: 100%;
      max-width: 800px;
      justify-content: center;
    }
    #mainTabs button {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
    }
    #mainTabs button.active {
      background: #444;
      font-weight: bold;
    }
    /* Join Stream Button */
    #joinStreamBtn {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
      margin-left: 10px;
      display: none;
    }
    
    .tab-content {
      border: 1px solid #555;
      padding: 10px;
      margin-bottom: 20px;
      width: 90%;
      max-width: 800px;
      background-color: #1e1e1e;
      border-radius: 10px;
    }
    /* Chat container: height adjusted and rounded */
    #chatLog {
      width: 300px;
      height: 200px;
      border: 1px solid #555;
      border-radius: 10px;
      overflow-y: auto;
      padding: 5px;
      background: #2a2a2a;
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin: 10px auto;
    }
    /* Center file transfer options in Chat tab */
    #chatInputContainer {
      margin-top: 10px;
      text-align: center;
    }
    /* Chat bubbles */
    .chat-bubble {
      display: inline-block;
      padding: 8px 12px;
      margin: 4px;
      border-radius: 15px;
      max-width: 50%;
      word-wrap: break-word;
    }
    .chat-bubble.me {
      background-color: #3a663a;
      align-self: flex-end;
    }
    .chat-bubble.peer {
      background-color: #2a4f6c;
      align-self: flex-start;
    }
    /* File link styling */
    .file-link a {
      text-decoration: none;
    }
    .file-link.me a { color: #8fbc8f; }
    .file-link.peer a { color: #6495ed; }
    /* QR Code container with white background and padding */
    #qrCodeContainer {
      margin-top: 10px;
      padding: 20px;
      background: #fff;
      color: #121212;
      display: inline-block;
      border-radius: 5px;
    }
    /* QR scanner container */
    #qr-reader {
      width: 300px;
      margin-top: 10px;
      display: none;
    }
    /* Call/Stream sub-tabs - centered and same size */
    #callStreamTabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
    }
    #callStreamTabs button {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
      width: 100px;
    }
    #callStreamTabs button.active {
      background: #444;
      font-weight: bold;
    }
    /* Containers for Call and Stream features */
    #callContainer, #streamContainer {
      border: 1px solid #555;
      padding: 10px;
      margin: 10px 0;
      background-color: #1e1e1e;
      border-radius: 10px;
    }
    /* Video Call container */
    #videoCallContainer {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: auto;
    }
    #videoCallContainer .remote-video {
      width: 100%;
      height: auto;
      background: black;
    }
    #videoCallContainer .local-video {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 30%;
      border: 2px solid #444;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    /* Footer */
    footer {
      font-size: 10px;
      margin-top: auto;
      padding: 5px;
      color: #888;
    }
  </style>
  <!-- Required libraries -->
  <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode"></script>
</head>
<body>
  <h1>GEMINI CHAT AND SHARE</h1>
  <!-- Connection status -->
  <div id="connectionStatus">Disconnected</div>

  <!-- Main Tabs -->
  <div id="mainTabs">
    <button id="mainTabConnection" class="active">Connection</button>
    <button id="mainTabChat">Chat &amp; Share</button>
    <button id="mainTabCallStream">Call/Stream</button>
    <button id="joinStreamBtn" class="glow-blue">Join Stream</button>
  </div>

  <!-- Connection Tab Content -->
  <div id="tabContentConnection" class="tab-content">
    <div id="automaticSignaling">
      <h2>PeerJS Signaling</h2>
      <button id="createRoomBtn">Create Room</button>
      <button id="copyRoomIdBtn">Copy Room ID</button>
      <br>
      <input type="text" id="roomIdInput" placeholder="Room ID">
      <button id="joinRoomBtn">Join Room</button>
      <div id="peerStatus"></div>
      <div id="qrCodeContainer"></div>
      <button id="scanQRCodeBtn">Scan QR Code</button>
      <button id="closeScannerBtn" style="display:none;">Close Scanner</button>
      <div id="qr-reader"></div>
    </div>
  </div>

  <!-- Chat & Share Tab Content -->
  <div id="tabContentChat" class="tab-content" style="display:none;">
    <section id="chat-section">
      <h2>Chat and File Transfer</h2>
      <div id="chatLog"></div>
      <div id="chatInputContainer">
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendChatBtn">Send Chat</button>
        <div style="display: flex; justify-content: center; align-items: center;">
          <input type="file" id="fileInput">
          <button id="sendFileBtn">Send File</button>
          <button id="endFileTransferBtn" style="display:none;">End Transfer</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Call/Stream Tab Content -->
  <div id="tabContentCallStream" class="tab-content" style="display:none;">
    <div id="callStreamTabs">
      <button id="subTabCall" class="active">Call</button>
      <button id="subTabStream">Stream</button>
    </div>
    <div id="callSubContent">
      <!-- Call Features -->
      <div id="callContainer">
        <!-- Video Call Section -->
        <div id="videoCallSection">
          <h2>Video Call</h2>
          <button id="startVideoCallBtn">Start Video Call</button>
          <button id="endCallBtn">End Video Call</button>
          <div id="videoCallContainer">
            <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
            <video id="localVideo" class="local-video" autoplay muted playsinline></video>
          </div>
        </div>
      </div>
      <!-- Stream Features -->
      <div id="streamContainer" style="display:none;">
        <!-- Video Streaming Section -->
        <div id="videoStreamSection">
          <h2>Video Streaming</h2>
          <p><strong>Select a video file to stream:</strong></p>
          <input type="file" id="videoFileInput" accept="video/*">
          <button id="startVideoStreamBtn">Start Video Stream</button>
          <button id="endStreamBtn">End Video Stream</button>
          <br>
          <p><strong>Local Stream (Sender's Playback):</strong></p>
          <video id="localStreamedVideo" controls playsinline style="width:300px"></video>
          <p><strong>Remote Stream (Receiver's Playback):</strong></p>
          <video id="remoteStreamedVideo" autoplay playsinline style="width:300px"></video>
          <br>
          <button id="enterFullscreenBtn">Full Screen Mode</button>
          <button id="exitFullscreenBtn" style="display:none;">Exit Full Screen</button>
        </div>
      </div>
    </div>
  </div>

  <footer>Developed by Jijo.</footer>

  <script>
    /***** Global Variables *****/
    let currentMainTab = "connection";
    let currentSubTab = "";
    let isOfferer = null;
    let dcPeer = null;
    let dataChannel = null;
    let videoCallPeer = null;
    let videoStreamPeer = null;
    let fileReceiver = null;
    let peer = null;
    let signalingConn = null;
    let sdpSent = false;
    let isStreamSender = false;

    let html5QrCodeScannerInstance = null;
    let currentSendProgressElem = null;
    let currentReceiveProgressElem = null;

    /***** ICE Servers Configuration *****/
    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' }
    ];

    /***** Tab Switching Functions *****/
    function switchMainTab(tabName) {
      document.getElementById("tabContentConnection").style.display = "none";
      document.getElementById("tabContentChat").style.display = "none";
      document.getElementById("tabContentCallStream").style.display = "none";
      document.getElementById("mainTabConnection").classList.remove("active", "glow-red", "glow-green");
      document.getElementById("mainTabChat").classList.remove("active", "glow-green");
      document.getElementById("mainTabCallStream").classList.remove("active", "glow-green");
      if(tabName === "connection") {
        document.getElementById("tabContentConnection").style.display = "block";
        document.getElementById("mainTabConnection").classList.add("active");
      } else if(tabName === "chat") {
        document.getElementById("tabContentChat").style.display = "block";
        document.getElementById("mainTabChat").classList.add("active");
      } else if(tabName === "callstream") {
        document.getElementById("tabContentCallStream").style.display = "block";
        document.getElementById("mainTabCallStream").classList.add("active");
      }
      currentMainTab = tabName;
      if(tabName === "callstream") {
        document.getElementById("joinStreamBtn").style.display = "none";
      }
    }
    document.getElementById("mainTabConnection").onclick = () => { switchMainTab("connection"); };
    document.getElementById("mainTabChat").onclick = () => { switchMainTab("chat"); };
    document.getElementById("mainTabCallStream").onclick = () => { switchMainTab("callstream"); };

    function switchCallStreamSubTab(tabName) {
      document.getElementById("callContainer").style.display = "none";
      document.getElementById("streamContainer").style.display = "none";
      document.getElementById("subTabCall").classList.remove("active", "glow-green");
      document.getElementById("subTabStream").classList.remove("active", "glow-green");
      if(tabName === "call") {
        document.getElementById("callContainer").style.display = "block";
        document.getElementById("subTabCall").classList.add("active");
      } else if(tabName === "stream") {
        document.getElementById("streamContainer").style.display = "block";
        document.getElementById("subTabStream").classList.add("active");
      }
      currentSubTab = tabName;
    }
    document.getElementById("subTabCall").onclick = () => { switchCallStreamSubTab("call"); };
    document.getElementById("subTabStream").onclick = () => { switchCallStreamSubTab("stream"); };

    /***** Utility Functions *****/
    function updateConnectionStatus(status) {
      const elem = document.getElementById("connectionStatus");
      elem.innerText = status;
      elem.style.fontWeight = "bold";
      elem.style.color = "#e0e0e0";
      if (status.toLowerCase() === "connected") {
        elem.style.color = "green";
        document.getElementById("mainTabConnection").classList.remove("glow-red");
      } else if (status.toLowerCase() === "connecting") {
        elem.style.color = "blue";
      } else if (status.toLowerCase() === "disconnected") {
        elem.style.color = "red";
        document.getElementById("mainTabConnection").classList.add("glow-red");
      } else if (status.toLowerCase() === "failed connecting") {
        elem.style.color = "orange";
      }
    }
    function logChat(message, sender) {
      const chatLog = document.getElementById("chatLog");
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      if(sender === "me") {
        bubble.classList.add("me");
      } else if(sender === "peer") {
        bubble.classList.add("peer");
      } else {
        bubble.classList.add("system");
      }
      bubble.innerText = message;
      chatLog.appendChild(bubble);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    function logFileBubble(linkElement, sender) {
      const chatLog = document.getElementById("chatLog");
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      if(sender === "me") {
        bubble.classList.add("me");
      } else {
        bubble.classList.add("peer");
      }
      bubble.appendChild(linkElement);
      chatLog.appendChild(bubble);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    /***** Setup for Data Channel *****/
    function setupDataChannelConnection() {
      dcPeer = new RTCPeerConnection({ iceServers });
      dcPeer.onicecandidate = event => {
        if (event.candidate) {
          sendSignalingMessage({ type: "candidate", candidate: event.candidate });
        }
      };
      if (isOfferer) {
        dataChannel = dcPeer.createDataChannel("chat");
        setupDataChannel();
      } else {
        dcPeer.ondatachannel = event => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }
    }
    function setupDataChannel() {
      dataChannel.onopen = () => {
        logChat("Data channel open.", "system");
        updateConnectionStatus("Connected");
        switchMainTab("chat");
        if (peer) {
          peer.destroy();
          peer = null;
          document.getElementById("peerStatus").innerText = "PeerJS connection closed.";
        }
      };
      dataChannel.onclose = () => { 
        updateConnectionStatus("Disconnected"); 
        logChat("Data channel closed.", "system");
      };
      dataChannel.onmessage = event => {
        try {
          let msg = JSON.parse(event.data);
          handleDataChannelMessage(msg);
        } catch (e) {
          handleFileChunk(event.data);
        }
      };
    }

    /***** PeerJS Signaling *****/
    function sendSignalingMessage(msg) {
      if (signalingConn && signalingConn.open) {
        signalingConn.send(JSON.stringify(msg));
      }
    }
    function handleSignalingMessage(msg) {
      switch (msg.type) {
        case "offer":
  (async () => {
    isOfferer = false;
    setupDataChannelConnection();
    await dcPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    const answer = await dcPeer.createAnswer();
    await dcPeer.setLocalDescription(answer);
    // send the answer SDP back to the offerer
    sendSignalingMessage({ type: "answer", sdp: dcPeer.localDescription });
  })();
  break;
        case "answer":
          dcPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          break;
        case "candidate":
          if (dcPeer) { dcPeer.addIceCandidate(new RTCIceCandidate(msg.candidate)); }
          break;
        case "end-stream":
          document.getElementById("remoteStreamedVideo").srcObject = null;
          logChat("Video stream ended by peer.", "peer");
          break;
        default:
          console.log("Unknown signaling message:", msg.type);
      }
    }

    /***** Automatic Signaling (PeerJS) *****/
    document.getElementById("createRoomBtn").onclick = () => {
      peer = new Peer();
      peer.on('open', id => {
        document.getElementById("roomIdInput").value = id;
        document.getElementById("peerStatus").innerText = "Room created with ID: " + id;
        isOfferer = true;
        const qrContainer = document.getElementById("qrCodeContainer");
        qrContainer.innerHTML = "";
        new QRCode(qrContainer, {
          text: id,
          width: 128,
          height: 128,
          colorDark: "#121212",
          colorLight: "#fff",
          correctLevel: QRCode.CorrectLevel.H
        });
      });
      peer.on('connection', conn => {
        signalingConn = conn;
        signalingConn.on('data', data => { handleSignalingMessage(JSON.parse(data)); });
        signalingConn.on('open', async () => {
  document.getElementById("peerStatus").innerText += " – Signaling connection established.";
  setupDataChannelConnection();
  try {
    const offer = await dcPeer.createOffer();
    await dcPeer.setLocalDescription(offer);
    // send the offer SDP to the remote peer via PeerJS
    sendSignalingMessage({ type: "offer", sdp: dcPeer.localDescription });
  } catch (err) {
    console.error("Failed to create/send offer:", err);
  }
});
      });
      peer.on('error', err => {
        console.error('PeerJS error:', err);
        updateConnectionStatus("Failed connecting");
      });
    };
    document.getElementById("copyRoomIdBtn").onclick = () => {
      const roomId = document.getElementById("roomIdInput").value;
      navigator.clipboard.writeText(roomId);
    };
    document.getElementById("joinRoomBtn").onclick = () => {
      const roomId = document.getElementById("roomIdInput").value;
      if (!roomId) return alert("Please enter a Room ID to join.");
      peer = new Peer();
      peer.on('open', id => {
        document.getElementById("peerStatus").innerText = "Your PeerJS ID: " + id;
        signalingConn = peer.connect(roomId);
        signalingConn.on('open', () => {
          document.getElementById("peerStatus").innerText += " – Connected to room " + roomId;
        });
        signalingConn.on('data', data => { handleSignalingMessage(JSON.parse(data)); });
      });
      peer.on('error', err => {
        console.error('PeerJS error:', err);
        updateConnectionStatus("Failed connecting");
      });
      updateConnectionStatus("Connecting");
    };

    /***** QR Code Scanning using Html5Qrcode *****/
    function startQrScanner() {
      const qrReaderElem = document.getElementById("qr-reader");
      qrReaderElem.style.display = "block";
      html5QrCodeScannerInstance = new Html5Qrcode("qr-reader");
      const config = { fps: 10, qrbox: 250 };
      html5QrCodeScannerInstance.start(
        { facingMode: "environment" },
        config,
        (decodedText, decodedResult) => {
          console.log("QR Code detected: ", decodedText);
          document.getElementById("roomIdInput").value = decodedText;
          html5QrCodeScannerInstance.stop().then(() => {
            qrReaderElem.style.display = "none";
            document.getElementById("closeScannerBtn").style.display = "none";
            document.getElementById("scanQRCodeBtn").style.display = "inline";
            document.getElementById("joinRoomBtn").click();
          }).catch(err => { console.error("Failed to stop scanner: ", err); });
        },
        errorMessage => { console.log("QR scan error: ", errorMessage); }
      ).catch(err => { console.error("Unable to start scanning.", err); });
    }
    document.getElementById("scanQRCodeBtn").onclick = function() {
      startQrScanner();
      this.style.display = "none";
      document.getElementById("closeScannerBtn").style.display = "inline";
    };
    document.getElementById("closeScannerBtn").onclick = function() {
      if (html5QrCodeScannerInstance) {
        html5QrCodeScannerInstance.stop().then(() => {
          document.getElementById("qr-reader").style.display = "none";
          html5QrCodeScannerInstance = null;
          this.style.display = "none";
          document.getElementById("scanQRCodeBtn").style.display = "inline";
        }).catch(err => { console.error("Error stopping QR scanner: ", err); });
      }
    };

    /***** Data Channel Message Handling *****/
    function handleDataChannelMessage(msg) {
      switch (msg.type) {
        case "chat":
          logChat(msg.message, "peer");
          if(currentMainTab !== "chat") {
            document.getElementById("mainTabChat").classList.add("glow-green");
          }
          break;
        case "file-meta":
          fileReceiver = {
            name: msg.name,
            size: msg.size,
            type: msg.fileType,
            received: [],
            receivedSize: 0
          };
          currentReceiveProgressElem = document.createElement("div");
          currentReceiveProgressElem.classList.add("chat-bubble", "peer");
          currentReceiveProgressElem.innerText = "Receiving file: " + msg.name + " (0%)";
          document.getElementById("chatLog").appendChild(currentReceiveProgressElem);
          if(currentMainTab !== "chat") {
            document.getElementById("mainTabChat").classList.add("glow-green");
          }
          break;
        case "video-offer":
          handleVideoOffer(msg.sdp);
          break;
        case "video-answer":
          handleVideoAnswer(msg.sdp);
          break;
        case "video-candidate":
          if (videoCallPeer) { videoCallPeer.addIceCandidate(new RTCIceCandidate(msg.candidate)); }
          break;
        case "stream-offer":
          handleStreamOffer(msg.sdp);
          if(currentMainTab !== "callstream" || currentSubTab !== "stream") {
            document.getElementById("mainTabCallStream").classList.add("glow-green");
            document.getElementById("subTabStream").classList.add("glow-green");
            document.getElementById("joinStreamBtn").style.display = "inline";
          }
          break;
        case "stream-answer":
          handleStreamAnswer(msg.sdp);
          break;
        case "stream-candidate":
          if (videoStreamPeer) { videoStreamPeer.addIceCandidate(new RTCIceCandidate(msg.candidate)); }
          break;
        case "call-request":
          if (confirm("Incoming video call from peer. Accept call?")) {
            dataChannel.send(JSON.stringify({ type: "call-response", accepted: true }));
            switchMainTab("callstream");
            switchCallStreamSubTab("call");
            prepareVideoCallForCallee();
          } else {
            dataChannel.send(JSON.stringify({ type: "call-response", accepted: false }));
          }
          break;
        case "call-response":
          if (msg.accepted) {
            startVideoCallCaller();
          } else {
            alert("Your video call request was rejected.");
          }
          break;
        case "end-stream":
          document.getElementById("remoteStreamedVideo").srcObject = null;
          logChat("Video stream ended by peer.", "peer");
          break;
        default:
          console.log("Unknown message type:", msg.type);
      }
    }

    /***** Combined Chat & File Transfer *****/
    document.getElementById("sendChatBtn").onclick = () => {
      const input = document.getElementById("chatInput");
      const text = input.value;
      if (dataChannel && dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({ type: "chat", message: text }));
        logChat(text, "me");
        input.value = "";
      }
    };
    document.getElementById("sendFileBtn").onclick = () => {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return;
      document.getElementById("endFileTransferBtn").style.display = "inline";
      currentSendProgressElem = document.createElement("div");
      currentSendProgressElem.classList.add("chat-bubble", "me");
      currentSendProgressElem.innerText = "Sending file: " + file.name + " (0%)";
      document.getElementById("chatLog").appendChild(currentSendProgressElem);
      dataChannel.send(JSON.stringify({ type: "file-meta", name: file.name, size: file.size, fileType: file.type }));
      const chunkSize = 262144;
      let offset = 0;
      const reader = new FileReader();
      reader.onload = e => {
        dataChannel.send(e.target.result);
        offset += e.target.result.byteLength;
        let progress = Math.floor((offset / file.size) * 100);
        currentSendProgressElem.innerText = "Sending file: " + file.name + " (" + progress + "%)";
        if (offset < file.size) {
          readSlice(offset);
        } else {
          currentSendProgressElem.innerText = file.name;
          document.getElementById("endFileTransferBtn").style.display = "none";
          currentSendProgressElem = null;
        }
      };
      const readSlice = o => {
        const slice = file.slice(o, o + chunkSize);
        reader.readAsArrayBuffer(slice);
      };
      readSlice(0);
    };
    document.getElementById("endFileTransferBtn").onclick = () => {
      fileReceiver = null;
      logChat("File transfer canceled.", "me");
      document.getElementById("endFileTransferBtn").style.display = "none";
      if (currentSendProgressElem) { currentSendProgressElem.innerText = "File transfer canceled."; currentSendProgressElem = null; }
      if (currentReceiveProgressElem) { currentReceiveProgressElem.innerText = "File transfer canceled."; currentReceiveProgressElem = null; }
    };
    function handleFileChunk(chunk) {
      if (!fileReceiver) return;
      fileReceiver.received.push(chunk);
      fileReceiver.receivedSize += chunk.byteLength;
      let progress = Math.floor((fileReceiver.receivedSize / fileReceiver.size) * 100);
      if (currentReceiveProgressElem)
        currentReceiveProgressElem.innerText = "Receiving file: " + fileReceiver.name + " (" + progress + "%)";
      if (fileReceiver.receivedSize >= fileReceiver.size) {
        const blob = new Blob(fileReceiver.received, { type: fileReceiver.type });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = fileReceiver.name;
        link.innerText = fileReceiver.name;
        link.classList.add("file-link", "peer");
        logFileBubble(link, "peer");
        if (currentReceiveProgressElem) currentReceiveProgressElem.remove();
        fileReceiver = null;
        currentReceiveProgressElem = null;
      }
    }

    /***** Video Call Functions *****/
    document.getElementById("startVideoCallBtn").onclick = () => {
      if (!dataChannel || dataChannel.readyState !== "open") { alert("Data channel is not open."); return; }
      dataChannel.send(JSON.stringify({ type: "call-request" }));
    };
    async function startVideoCallCaller() {
      if (videoCallPeer) { videoCallPeer.close(); videoCallPeer = null; }
      const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      document.getElementById("localVideo").srcObject = localStream;
      videoCallPeer = new RTCPeerConnection({ iceServers });
      localStream.getTracks().forEach(track => videoCallPeer.addTrack(track, localStream));
      videoCallPeer.onicecandidate = event => {
        if (event.candidate) {
          dataChannel.send(JSON.stringify({ type: "video-candidate", candidate: event.candidate }));
        }
      };
      videoCallPeer.ontrack = event => {
        document.getElementById("remoteVideo").srcObject = event.streams[0];
      };
      const offer = await videoCallPeer.createOffer();
      await videoCallPeer.setLocalDescription(offer);
      dataChannel.send(JSON.stringify({ type: "video-offer", sdp: videoCallPeer.localDescription }));
    }
    async function prepareVideoCallForCallee() {
      if (videoCallPeer) { videoCallPeer.close(); videoCallPeer = null; }
      const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      document.getElementById("localVideo").srcObject = localStream;
      videoCallPeer = new RTCPeerConnection({ iceServers });
      localStream.getTracks().forEach(track => videoCallPeer.addTrack(track, localStream));
      videoCallPeer.onicecandidate = event => {
        if (event.candidate) {
          dataChannel.send(JSON.stringify({ type: "video-candidate", candidate: event.candidate }));
        }
      };
      videoCallPeer.ontrack = event => {
        document.getElementById("remoteVideo").srcObject = event.streams[0];
      };
    }
    document.getElementById("endCallBtn").onclick = () => {
      if (videoCallPeer) { videoCallPeer.close(); videoCallPeer = null; }
      const localVideo = document.getElementById("localVideo");
      if (localVideo.srcObject) {
        localVideo.srcObject.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
      }
      document.getElementById("remoteVideo").srcObject = null;
      logChat("Video call ended.", "me");
    };
    async function handleVideoOffer(sdp) {
      await videoCallPeer.setRemoteDescription(new RTCSessionDescription(sdp));
      const answer = await videoCallPeer.createAnswer();
      await videoCallPeer.setLocalDescription(answer);
      dataChannel.send(JSON.stringify({ type: "video-answer", sdp: videoCallPeer.localDescription }));
    }
    async function handleVideoAnswer(sdp) {
      if (videoCallPeer) { await videoCallPeer.setRemoteDescription(new RTCSessionDescription(sdp)); }
    }

    /***** Video Streaming Functions *****/
    document.getElementById("startVideoStreamBtn").onclick = async () => {
      if (!dataChannel || dataChannel.readyState !== "open") { alert("Data channel is not open."); return; }
      const fileInput = document.getElementById("videoFileInput");
      const file = fileInput.files[0];
      if (!file) return;
      isStreamSender = true;
      if (videoStreamPeer) { videoStreamPeer.close(); videoStreamPeer = null; }
      const localStreamedVideo = document.getElementById("localStreamedVideo");
      if (localStreamedVideo.srcObject) {
        localStreamedVideo.srcObject.getTracks().forEach(track => track.stop());
      }
      const fileURL = URL.createObjectURL(file);
      localStreamedVideo.src = fileURL;
      localStreamedVideo.muted = false;
      localStreamedVideo.load();
      await new Promise(resolve => { localStreamedVideo.onloadedmetadata = resolve; });
      await localStreamedVideo.play();
      const stream = localStreamedVideo.captureStream();
      videoStreamPeer = new RTCPeerConnection({ iceServers });
      stream.getTracks().forEach(track => videoStreamPeer.addTrack(track, stream));
      videoStreamPeer.onicecandidate = event => {
        if (event.candidate) {
          dataChannel.send(JSON.stringify({ type: "stream-candidate", candidate: event.candidate }));
        }
      };
      const offer = await videoStreamPeer.createOffer();
      await videoStreamPeer.setLocalDescription(offer);
      dataChannel.send(JSON.stringify({ type: "stream-offer", sdp: videoStreamPeer.localDescription }));
    };
    document.getElementById("endStreamBtn").onclick = () => {
      if (isStreamSender) {
        if (videoStreamPeer) { videoStreamPeer.close(); videoStreamPeer = null; }
        const localStreamedVideo = document.getElementById("localStreamedVideo");
        if (localStreamedVideo.srcObject) {
          localStreamedVideo.srcObject.getTracks().forEach(track => track.stop());
          localStreamedVideo.srcObject = null;
        }
        dataChannel.send(JSON.stringify({ type: "end-stream" }));
        document.getElementById("remoteStreamedVideo").srcObject = null;
        logChat("Video stream ended.", "me");
        isStreamSender = false;
      } else {
        document.getElementById("remoteStreamedVideo").srcObject = null;
        logChat("Remote video stream cleared.", "me");
      }
    };
    async function handleStreamOffer(sdp) {
      if (videoStreamPeer) { videoStreamPeer.close(); videoStreamPeer = null; }
      videoStreamPeer = new RTCPeerConnection({ iceServers });
      videoStreamPeer.onicecandidate = event => {
        if (event.candidate) {
          dataChannel.send(JSON.stringify({ type: "stream-candidate", candidate: event.candidate }));
        }
      };
      videoStreamPeer.ontrack = event => {
        document.getElementById("remoteStreamedVideo").srcObject = event.streams[0];
      };
      await videoStreamPeer.setRemoteDescription(new RTCSessionDescription(sdp));
      const answer = await videoStreamPeer.createAnswer();
      await videoStreamPeer.setLocalDescription(answer);
      dataChannel.send(JSON.stringify({ type: "stream-answer", sdp: videoStreamPeer.localDescription }));
    }
    async function handleStreamAnswer(sdp) {
      if (videoStreamPeer) { await videoStreamPeer.setRemoteDescription(new RTCSessionDescription(sdp)); }
    }

    /***** Full Screen Controls *****/
    const remoteStreamedVideo = document.getElementById("remoteStreamedVideo");
    document.getElementById("enterFullscreenBtn").innerText = "Full Screen Mode";
    document.getElementById("enterFullscreenBtn").onclick = async () => {
      if (remoteStreamedVideo.requestFullscreen) {
        await remoteStreamedVideo.requestFullscreen();
        document.getElementById("enterFullscreenBtn").style.display = "none";
        document.getElementById("exitFullscreenBtn").style.display = "inline";
      }
    };
    document.getElementById("exitFullscreenBtn").onclick = async () => {
      if (document.exitFullscreen) {
        await document.exitFullscreen();
        document.getElementById("enterFullscreenBtn").style.display = "inline";
        document.getElementById("exitFullscreenBtn").style.display = "none";
      }
    };
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        document.getElementById("enterFullscreenBtn").style.display = "inline";
        document.getElementById("exitFullscreenBtn").style.display = "none";
      }
    });

    /***** Join Stream Button Functionality *****/
    document.getElementById("joinStreamBtn").onclick = () => {
      document.getElementById("joinStreamBtn").style.display = "none";
      switchMainTab("callstream");
      switchCallStreamSubTab("stream");
      document.getElementById("mainTabCallStream").classList.remove("glow-green");
      document.getElementById("subTabStream").classList.remove("glow-green");
    };

    /***** Initialize App *****/
    updateConnectionStatus("Disconnected");
  </script>
</body>
</html>
