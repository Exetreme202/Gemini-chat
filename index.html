<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebRTC Chat (Upgraded)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        *{box-sizing:border-box;margin:0;padding:0;font-family:Arial,Helvetica,sans-serif} 
        body{max-width:1100px;margin:0 auto;padding:20px;background:#f5f5f5} 
        h1{text-align:center;margin-bottom:20px;color:#333} 
        .container{display:flex;flex-direction:column;gap:20px} 
        .connection-panel,.chat-panel,.media-panel,.file-panel,.stream-panel{ 
            background:#fff;padding:15px;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,.08) 
        } 
        .input-group{display:flex;gap:10px;margin-bottom:10px} 
        input,button{padding:10px 12px;border:1px solid #ddd;border-radius:6px} 
        input{flex:1} 
        button{background:#4CAF50;color:#fff;border:none;cursor:pointer;transition:background .2s} 
        button:hover{background:#45a049} 
        button.secondary{background:#2196F3} 
        button.secondary:hover{background:#0b7dda} 
        button.warn{background:#9C27B0} 
        button.warn:hover{background:#7b1fa2} 
        button:disabled{background:#ccc;cursor:not-allowed} 
        #chatMessages{height:200px;overflow-y:auto;border:1px solid #ddd;padding:10px;margin-bottom:10px;border-radius:6px;display:flex;flex-direction:column;gap:8px} 
        .message{max-width:70%;padding:8px 12px;border-radius:18px;line-height:1.4;word-wrap:break-word;position:relative} 
        .local{align-self:flex-end;background:#dcf8c6;margin-left:30%} 
        .remote{align-self:flex-start;background:#f0f0f0;margin-right:30%} 
        .video-container{position:relative;width:100%;max-width:820px;margin:0 auto;background:#000;border-radius:12px;overflow:hidden} 
        #remoteVideo{width:100%;height:auto;display:block} 
        #localVideo{ 
            position:absolute;bottom:20px;right:20px;width:40%;max-width:320px;height:auto;border:2px solid #fff;border-radius:8px;z-index:10 
        } 
        .stream-video-container{display:flex;flex-direction:column;gap:16px;margin-bottom:10px;align-items:center} 
        .stream-video{width:100%;max-width:900px;background:#000;border-radius:12px;overflow:hidden} 
        .stream-video video{width:100%;height:auto;display:block} 
        .file-info{margin-top:10px;padding:10px;background:#f9f9f9;border-radius:6px;display:block} 
        .status{margin-top:10px;font-style:italic;color:#666} 
        .typing-indicator{height:20px;color:#666;font-style:italic;margin-bottom:5px;visibility:hidden} 
        .id-section{display:flex;align-items:center;gap:10px;margin-bottom:10px} 
        .connection-status{display:inline-block;width:12px;height:12px;border-radius:50%;margin-right:6px;border:1px solid #ddd} 
        .status-connected{background:#4CAF50} 
        .status-disconnected{background:#F44336} 
        .transfer-list{display:flex;flex-direction:column;gap:8px} 
        .transfer-item{padding:8px;border:1px solid #eee;border-radius:8px;background:#fff} 
        .transfer-top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px} 
        .transfer-name{font-weight:bold;word-break:break-all} 
        .progress-bar{width:100%;height:8px;background:#eee;border-radius:999px;overflow:hidden} 
        .progress{height:100%;width:0%} 
        .progress[data-type="send"]{background:#4CAF50} 
        .progress[data-type="recv"]{background:#2196F3} 
        .file-link{display:inline-block;margin-top:6px;text-decoration:underline;color:#2196F3;cursor:pointer} 
        /* Modal */ 
        .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:9999} 
        .modal{background:#111;color:#fff;width:min(92vw,900px);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.3);overflow:hidden} 
        .modal-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:#1c1c1c} 
        .modal-header button{background:#e0e0e0;color:#111;border:none;border-radius:6px;padding:8px 10px} 
        .modal-body{padding:12px} 
        .modal-body img,.modal-body video{width:100%;height:auto;display:block;border-radius:8px;background:#000} 
        .player-controls{display:flex;align-items:center;gap:10px;margin-top:10px} 
        .player-controls button{background:#4CAF50} 
        .player-controls input[type="range"]{flex:1} 
        .inline-back{background:#e0e0e0;color:#111;border:none;border-radius:6px;padding:6px 8px;cursor:pointer} 
        @media (max-width:560px){ 
            #localVideo{width:45%;max-width:50vw} 
            .message{max-width:85%} 
        }
        .username-section {margin-bottom: 10px;}
    </style>
</head>
<body>
    <h1>Simple WebRTC Chat</h1>
    
    <div class="container">
        <div class="connection-panel">
            <h2>Connection</h2>
            <div class="username-section">
                <div class="input-group">
                    <input type="text" id="usernameInput" placeholder="Enter your username">
                    <button id="saveUsernameButton">Save Username</button>
                </div>
                <div id="usernameStatus">No username set</div>
            </div>
            <div class="id-section">
                <span>Your ID: <span id="myId">Generating...</span></span>
                <button id="copyIdButton" disabled>Copy ID</button>
            </div>
            <div class="input-group">
                <input type="text" id="peerIdInput" placeholder="Peer ID to connect">
                <button id="connectButton">Connect</button>
            </div>
            <div class="status">
                <span class="connection-status" id="statusDot"></span>
                <span id="connectionStatus">Status: Disconnected</span>
            </div>
        </div>
        
        <div class="chat-panel">
            <h2>Chat</h2>
            <div id="chatMessages"></div>
            <div id="typingIndicator" class="typing-indicator">Peer is typing...</div>
            <div class="input-group">
                <input type="text" id="messageInput" placeholder="Type a message" disabled>
                <button id="sendMessageButton" disabled>Send</button>
            </div>
        </div>
        
        <div class="media-panel">
            <h2>Video & Voice Call</h2>
            <div class="input-group">
                <button id="startVideoButton">Start Video Call</button>
                <button id="startVoiceButton">Start Voice Call</button>
                <button id="endCallButton" disabled>End Call</button>
            </div>
            <div class="video-container">
                <video id="remoteVideo" autoplay playsinline></video>
                <video id="localVideo" autoplay playsinline muted></video>
            </div>
        </div>
        
        <div class="stream-panel">
            <h2>Video Streaming</h2>
            <div class="input-group">
                <input type="file" id="streamFileInput" accept="video/*" style="display:none">
                <button onclick="document.getElementById('streamFileInput').click()">Select Video</button>
                <button id="startStreamButton" disabled>Start Stream</button>
                <button id="stopStreamButton" disabled>Stop Stream</button>
            </div>
            <div class="stream-video-container">
                <div class="stream-video">
                    <video id="localStreamVideo" controls></video>
                </div>
                <div class="stream-video">
                    <video id="remoteStreamVideo" controls autoplay></video>
                </div>
            </div>
        </div>
        
        <div class="file-panel">
            <h2>File Sharing</h2>
            <div class="input-group">
                <button id="btnShareDownloadable" class="secondary">Share downloadable files</button>
                <button id="btnShareNonDownloadable" class="secondary">Share non downloadable files</button>
                <input type="file" id="pickDownloadable" multiple style="display:none">
                <input type="file" id="pickNonDownloadable" accept="image/*,video/*" multiple style="display:none">
            </div>
            <h3>Transfers & Received Files</h3>
            <div id="transferList" class="transfer-list"></div>
        </div>
    </div>
    
    <!-- Modal -->
    <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <h3 id="modalTitle">Preview</h3>
                <!-- Removed the top back button as requested -->
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        /* ======================= Config & Globals ======================= */
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };

        let peer, connection, dataChannel;
        let localStream = null, remoteStream = null;
        let mediaCall = null, streamCall = null;
        let isCaller = false, connectedPeerId = null, typingTimer = null;
        let capturedMediaStream = null;
        let myUsername = '';
        let peerUsername = '';

        /* File transfer (256KB chunks - optimized) */
        const CHUNK_SIZE = 256 * 1024;
        const sendingTransfers = new Map();
        const receivingTransfers = new Map();

        /* =======================
        DOM
        ======================= */
        const myIdElement = document.getElementById('myId');
        const connectionStatusElement = document.getElementById('connectionStatus');
        const statusDot = document.getElementById('statusDot');
        const copyIdButton = document.getElementById('copyIdButton');
        const peerIdInput = document.getElementById('peerIdInput');
        const connectButton = document.getElementById('connectButton');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessageButton');
        const chatMessages = document.getElementById('chatMessages');
        const typingIndicator = document.getElementById('typingIndicator');
        const startVideoButton = document.getElementById('startVideoButton');
        const startVoiceButton = document.getElementById('startVoiceButton');
        const endCallButton = document.getElementById('endCallButton');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const streamFileInput = document.getElementById('streamFileInput');
        const startStreamButton = document.getElementById('startStreamButton');
        const stopStreamButton = document.getElementById('stopStreamButton');
        const localStreamVideo = document.getElementById('localStreamVideo');
        const remoteStreamVideo = document.getElementById('remoteStreamVideo');
        const btnShareDownloadable = document.getElementById('btnShareDownloadable');
        const btnShareNonDownloadable = document.getElementById('btnShareNonDownloadable');
        const pickDownloadable = document.getElementById('pickDownloadable');
        const pickNonDownloadable = document.getElementById('pickNonDownloadable');
        const transferList = document.getElementById('transferList');
        const usernameInput = document.getElementById('usernameInput');
        const saveUsernameButton = document.getElementById('saveUsernameButton');
        const usernameStatus = document.getElementById('usernameStatus');

        /* Modal */
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalBody = document.getElementById('modalBody');
        const modalTitle = document.getElementById('modalTitle');

        /* =======================
        PeerJS Init
        ======================= */
        function initializePeer() {
            peer = new Peer({ config, debug: 2 });

            peer.on('open', id => {
                myIdElement.textContent = id;
                updateConnectionStatus('disconnected', 'Ready to connect');
                copyIdButton.disabled = false;
            });

            peer.on('connection', conn => {
                if (connection && connection.open) { conn.close(); return; }
                connectedPeerId = conn.peer;
                setupDataConnection(conn);
                peerIdInput.value = conn.peer;
                connectButton.disabled = true;
            });

            // Incoming calls
            peer.on('call', call => {
                const callType = call.metadata && call.metadata.type ? call.metadata.type : 'media';

                try {
                    if (callType === 'media') {
                        if (streamCall) {
                            try { streamCall.close(); } catch(e) {}
                            streamCall = null;
                            stopCapturedMediaStream();
                        }
                        call.answer(localStream || undefined);
                        mediaCall = call;
                        setupMediaCallHandlers(call, 'media');
                    } else if (callType === 'stream') {
                        call.answer(undefined);
                        streamCall = call;
                        setupMediaCallHandlers(call, 'stream');
                    } else {
                        call.answer(localStream || undefined);
                        mediaCall = call;
                        setupMediaCallHandlers(call, 'media');
                    }
                } catch (err) {
                    console.error('Error answering call:', err);
                    updateConnectionStatus('error', 'Call answer failed');
                }
            });

            peer.on('disconnected', () => {
                updateConnectionStatus('disconnected', 'Peer disconnected');
                resetConnectionState();
            });

            peer.on('error', err => {
                console.error('PeerJS error:', err);
                updateConnectionStatus('error', 'Error: ' + (err && err.type ? err.type : err));
            });
        }

        /* =======================
        UI: Connection Status
        ======================= */
        function updateConnectionStatus(state, message){
            // Only allow connected or disconnected states
            if (state === 'connected') {
                connectionStatusElement.textContent = `Connected to ${peerUsername}`;
                statusDot.className = 'connection-status status-connected';
            } else {
                connectionStatusElement.textContent = 'Disconnected';
                statusDot.className = 'connection-status status-disconnected';
            }
        }

        /* =======================
        Data Connection Setup
        ======================= */
        function setupDataConnection(conn){
            connection = conn;
            connection.on('open', () => {
                dataChannel = connection;
                
                // Send our username to the peer
                if (myUsername) {
                    dataChannel.send({ type: 'username', username: myUsername });
                }
                
                messageInput.disabled = false;
                sendMessageButton.disabled = false;
                startStreamButton.disabled = false;
                connectedPeerId = connection.peer;

                setupDataChannel();
            });
            connection.on('close', () => {
                updateConnectionStatus('disconnected', 'Connection closed');
                resetConnectionState();
            });
            connection.on('error', err => {
                console.error('Connection error:', err);
                updateConnectionStatus('error', 'Connection error');
            });
        }

        function setupDataChannel(){
            if (!dataChannel) return;
            dataChannel.on('data', handleDataMessage);
            try {
                if (dataChannel._dc) dataChannel._dc.binaryType = 'arraybuffer';
            } catch(e){}
        }

        /* =======================
        Chat
        ======================= */
        function handleDataMessage(data){
            if (!data) return;
            try {
                switch(data.type){
                    case 'chat':
                        addMessage(data.message, 'remote');
                        break;
                    case 'typing-start':
                        typingIndicator.textContent = 'Peer is typing...';
                        typingIndicator.style.visibility = 'visible';
                        break;
                    case 'typing-stop':
                        typingIndicator.style.visibility = 'hidden';
                        break;
                    case 'username':
                        // Store peer's username and update UI
                        peerUsername = data.username;
                        updateConnectionStatus('connected', `Connected to ${peerUsername}`);
                        break;
                    /* File transfer protocol */
                    case 'file-meta':
                        startReceivingFile(data.meta);
                        break;
                    case 'file-chunk':
                        receiveFileChunk(data.id, data.seq, data.total, data.chunk);
                        break;
                    case 'file-complete':
                        finalizeReceivedFile(data.id);
                        break;
                    case 'file-progress':
                        updateSendProgressUI(data.id, data.percent);
                        break;
                    default:
                        // ignore
                        break;
                }
            } catch (err) {
                console.error('Error handling data message', err);
            }
        }

        function addMessage(message, type){
            const el = document.createElement('div');
            el.classList.add('message', type);
            el.textContent = message;
            chatMessages.appendChild(el);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function sendMessage(){
            const message = messageInput.value.trim();
            if (message && dataChannel){
                try {
                    dataChannel.send({type:'chat', message});
                    addMessage(message, 'local');
                    messageInput.value = '';
                } catch (err) {
                    console.error('Send message failed', err);
                }
            }
        }

        function handleTyping(){
            if (!dataChannel) return;
            try {
                dataChannel.send({type:'typing-start'});
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(() => dataChannel?.send({type:'typing-stop'}), 1000);
            } catch(e){}
        }

        /* =======================
        Calls (Video / Voice)
        ======================= */
        async function startVideoCall(){
            try{
                if (streamCall) {
                    try { streamCall.close(); } catch(e){}
                    streamCall = null;
                    stopCapturedMediaStream();
                }

                localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
                localVideo.srcObject = localStream;
                startCall('media');
            }catch(e){ alert('Could not access camera/mic'); console.error(e); }
        }

        async function startVoiceCall(){
            try{
                if (streamCall) {
                    try { streamCall.close(); } catch(e){}
                    streamCall = null;
                    stopCapturedMediaStream();
                }

                localStream = await navigator.mediaDevices.getUserMedia({video:false, audio:true});
                startCall('media');
            }catch(e){ alert('Could not access microphone'); console.error(e); }
        }

        function startCall(type='media'){
            if (!connection) return alert('Connect to a peer first');
            isCaller = true;
            endCallButton.disabled = false;

            if (mediaCall) {
                try { mediaCall.close(); } catch(e){}
                mediaCall = null;
            }

            const call = peer.call(connection.peer, localStream, { metadata: { type: type === 'stream' ? 'stream' : 'media' } });
            mediaCall = call;
            setupMediaCallHandlers(call, 'media');

            call.on('stream', () => {
                prioritizeBandwidth(call.peerConnection, 'video');
                prioritizeBandwidth(call.peerConnection, 'audio');
            });

            call.on('error', err => {
                console.error('Call error:', err);
                updateConnectionStatus('error', 'Media error');
            });
        }

        function endCall(){
            if (mediaCall){
                try{ mediaCall.close(); }catch(e){}
                mediaCall = null;
            }
            if (localStream){
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
                localVideo.srcObject = null;
            }
            if (remoteStream){
                try{ remoteStream.getTracks().forEach(t=>t.stop()); }catch(e){}
                remoteStream = null;
                remoteVideo.srcObject = null;
            }
            endCallButton.disabled = true;
            startStreamButton.disabled = !(connection && streamFileInput.files[0]);
        }

        function setupMediaCallHandlers(call, kind = 'media'){
            call.on('stream', stream => {
                if (kind === 'media') {
                    remoteStream = stream;
                    remoteVideo.srcObject = stream;
                    endCallButton.disabled = false;
                } else if (kind === 'stream') {
                    remoteStreamVideo.srcObject = stream;
                }
                try { prioritizeBandwidth(call.peerConnection, 'video'); } catch(e){}
            });

            call.on('close', () => {
                if (kind === 'media') {
                    endCall();
                } else if (kind === 'stream') {
                    stopStreaming();
                }
            });

            call.on('error', err => {
                console.error(kind + ' call error:', err);
                updateConnectionStatus('error', `${kind} media error`);
                if (kind === 'media') endCall();
                else stopStreaming();
            });
        }

        function prioritizeBandwidth(pc, kind = 'video'){
            if (!pc) return;
            try {
                const senders = pc.getSenders ? pc.getSenders() : [];
                senders.forEach(sender => {
                    if (!sender || !sender.track) return;
                    const trackKind = sender.track.kind;
                    if ((kind === 'video' && trackKind === 'video') || (kind === 'audio' && trackKind === 'audio')) {
                        const params = sender.getParameters ? sender.getParameters() : null;
                        if (params && params.encodings && params.encodings.length) {
                            params.encodings.forEach(enc => {
                                if (trackKind === 'video') {
                                    enc.maxBitrate = 5_000_000;
                                    enc.priority = 'high';
                                } else if (trackKind === 'audio') {
                                    enc.maxBitrate = enc.maxBitrate || 128_000;
                                    enc.priority = 'high';
                                }
                            });
                            try {
                                sender.setParameters(params).catch(()=>{});
                            } catch(e){}
                        }
                    }
                });
            } catch (e) {
                console.warn('Bandwidth prioritization not fully supported by browser', e);
            }
        }

        /* =======================
        Synchronized Streaming
        ======================= */
        async function startStreaming(){
            if (!connection) return alert('Please connect first');
            const file = streamFileInput.files[0];
            if (!file) return alert('Select a video file first');

            if (mediaCall) {
                try { mediaCall.close(); } catch(e){}
                mediaCall = null;
                if (localStream) {
                    localStream.getTracks().forEach(t=>t.stop());
                    localStream = null;
                    localVideo.srcObject = null;
                }
            }

            const fileURL = URL.createObjectURL(file);
            localStreamVideo.src = fileURL;
            localStreamVideo.onloadedmetadata = async () => {
                try {
                    await localStreamVideo.play();
                } catch(e){}

                if (!localStreamVideo.captureStream){ alert("Your browser doesn't support captureStream"); return; }
                
                try {
                    stopCapturedMediaStream();
                    capturedMediaStream = localStreamVideo.captureStream();
                    
                    const call = peer.call(connection.peer, capturedMediaStream, { metadata: { type: 'stream' } });
                    streamCall = call;
                    setupMediaCallHandlers(call, 'stream');
                    
                    call.on('stream', rStream => {
                        remoteStreamVideo.srcObject = rStream;
                    });
                    
                    call.on('close', stopStreaming);
                    
                    startStreamButton.disabled = true;
                    stopStreamButton.disabled = false;
                    
                    setTimeout(()=> {
                        try { prioritizeBandwidth(call.peerConnection, 'video'); } catch(e){}
                    }, 800);
                } catch (err) {
                    console.error('Start stream error', err);
                    alert('Failed to start stream');
                    stopCapturedMediaStream();
                }
            };
        }

        function stopCapturedMediaStream(){
            if (capturedMediaStream){
                try { capturedMediaStream.getTracks().forEach(t=>t.stop()); } catch(e){}
                capturedMediaStream = null;
            }
        }

        function stopStreaming(){
            if (streamCall){
                try{ streamCall.close(); }catch(e){}
                streamCall = null;
            }
            stopCapturedMediaStream();
            try { localStreamVideo.pause(); } catch(e){}
            localStreamVideo.src = '';
            remoteStreamVideo.srcObject = null;
            startStreamButton.disabled = !(connection && streamFileInput.files[0]);
            stopStreamButton.disabled = true;
        }

        /* =======================
        File Transfer (Chunked, optimized)
        ======================= */
        function uuid(){
            return 'f-' + Math.random().toString(36).slice(2) + '-' + Date.now().toString(36);
        }

        function humanSize(bytes){
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes/1024).toFixed(1) + ' KB';
            return (bytes/1048576).toFixed(1) + ' MB';
        }

        function createTransferUI(id, name, size, type){
            const wrap = document.createElement('div');
            wrap.className = 'transfer-item';
            wrap.id = `xfer-${id}`;

            const top = document.createElement('div');
            top.className = 'transfer-top';

            const nameEl = document.createElement('div');
            nameEl.className = 'transfer-name';
            nameEl.textContent = `${name} (${humanSize(size)})`;
            top.appendChild(nameEl);

            const pctEl = document.createElement('div');
            pctEl.id = `pct-${id}`;
            pctEl.textContent = '0%';
            top.appendChild(pctEl);

            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            const prog = document.createElement('div');
            prog.className = 'progress';
            prog.dataset.type = type;
            prog.style.width = '0%';
            bar.appendChild(prog);

            wrap.appendChild(top);
            wrap.appendChild(bar);

            transferList.appendChild(wrap);
            return {wrap, pctEl, prog};
        }

        function updateProgressUI(id, percent){
            const pctEl = document.getElementById(`pct-${id}`);
            const prog = document.querySelector(`#xfer-${id} .progress`);
            if (pctEl) pctEl.textContent = `${percent}%`;
            if (prog) prog.style.width = `${percent}%`;
        }

        function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }

        async function sendFileAsChunks(file, category){
            if (!dataChannel || !connection || !connection.open) return alert('Connect first');

            const id = uuid();
            const meta = { id, name: file.name, size: file.size, mime: file.type || 'application/octet-stream', category };
            const ui = createTransferUI(id, file.name, file.size, 'send');

            sendingTransfers.set(id, { file, offset: 0, total: file.size, name:file.name, size:file.size, mime:meta.mime, category, ui });

            try { dataChannel.send({ type: 'file-meta', meta }); } catch(e){ console.error('send meta failed', e); }

            const reader = new FileReader();
            let offset = 0;
            let seq = 0;
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

            function readSlice(o){ 
                const slice = file.slice(o, Math.min(o + CHUNK_SIZE, file.size)); 
                reader.readAsArrayBuffer(slice); 
            }

            reader.onload = async () => {
                const chunk = reader.result;
                try {
                    dataChannel.send({ type:'file-chunk', id, seq, total: totalChunks, chunk });
                } catch (err) {
                    try {
                        const blob = new Blob([chunk]);
                        const text = await blobToBase64(blob);
                        dataChannel.send({ type:'file-chunk', id, seq, total: totalChunks, chunkB64: text });
                    } catch(e){
                        console.error('Failed to send chunk', e);
                    }
                }

                offset += chunk.byteLength;
                seq += 1;
                
                const percent = Math.min(100, Math.floor((offset / file.size) * 100));
                updateProgressUI(id, percent);
                
                if (offset < file.size){
                    const adaptiveDelay = Math.min(40, Math.max(8, Math.floor((CHUNK_SIZE / 1024) / 6)));
                    await wait(adaptiveDelay);
                    readSlice(offset);
                } else {
                    try { 
                        dataChannel.send({ type:'file-complete', id }); 
                        console.log('File transfer complete:', id);
                    } catch(e){ 
                        console.error('send complete err', e); 
                    }
                }
            };

            readSlice(0);
        }

        function blobToBase64(blob){ return new Promise((res, rej) => {
            const r = new FileReader();
            r.onload = ()=> res(r.result.split(',')[1]);
            r.onerror = rej;
            r.readAsDataURL(blob);
        }); }

        function startReceivingFile(meta){
            const { id, name, size, category } = meta;
            const ui = createTransferUI(id, name, size, 'recv');
            receivingTransfers.set(id, { chunks: [], received: 0, total: size, totalChunks: Math.ceil(size / CHUNK_SIZE), meta, ui });
        }

        async function receiveFileChunk(id, seq, total, chunk){
            const rcv = receivingTransfers.get(id);
            if (!rcv) return;

            if (chunk) {
                try {
                    const arr = new Uint8Array(chunk);
                    rcv.chunks[seq] = arr;
                    rcv.received += arr.byteLength;
                } catch (e) {}
            }

            const pct = Math.min(100, Math.floor((rcv.received / rcv.total) * 100));
            updateProgressUI(id, pct);

            try { dataChannel?.send({ type: 'file-progress', id, percent: pct }); } catch(e){}

            // Check if we've received all chunks
            const receivedChunks = rcv.chunks.filter(chunk => chunk !== undefined).length;
            if (receivedChunks === rcv.totalChunks || rcv.received >= rcv.total){
                finalizeReceivedFile(id);
            }
        }

        function handleFallbackChunkB64(obj){
            const { id, seq, total, chunkB64 } = obj;
            if (!chunkB64) return;
            const rcv = receivingTransfers.get(id);
            if (!rcv) return;
            const byteString = atob(chunkB64);
            const arr = new Uint8Array(byteString.length);
            for (let i=0;i<byteString.length;i++) arr[i] = byteString.charCodeAt(i);
            rcv.chunks[seq] = arr;
            rcv.received += arr.byteLength;
            const pct = Math.min(100, Math.floor((rcv.received / rcv.total) * 100));
            updateProgressUI(id, pct);
            try { dataChannel?.send({ type: 'file-progress', id, percent: pct }); } catch(e){}
            
            // Check if we've received all chunks
            const receivedChunks = rcv.chunks.filter(chunk => chunk !== undefined).length;
            if (receivedChunks === rcv.totalChunks || rcv.received >= rcv.total){
                finalizeReceivedFile(id);
            }
        }

        function updateSendProgressUI(id, percent){
            updateProgressUI(id, Math.max(0, Math.min(100, Math.floor(percent))));
        }

        async function finalizeReceivedFile(id){
            const rcv = receivingTransfers.get(id);
            if (!rcv) return;

            // Verify we have all chunks
            const ordered = [];
            for (let i=0; i < rcv.totalChunks; i++){
                if (rcv.chunks[i]) {
                    ordered.push(rcv.chunks[i]);
                } else {
                    console.error('Missing chunk:', i, 'for file:', id);
                    return; // Don't finalize if chunks are missing
                }
            }

            // Check if we have the correct amount of data
            if (rcv.received !== rcv.total) {
                console.error('File size mismatch for:', id, 'Received:', rcv.received, 'Expected:', rcv.total);
                return;
            }

            const blob = new Blob(ordered, { type: rcv.meta.mime });
            
            const parent = document.getElementById(`xfer-${id}`);
            if (!parent) return;

            const line = document.createElement('div');
            line.style.marginTop = '6px';

            const link = document.createElement('a');
            link.className = 'file-link';
            
            if (rcv.meta.category === 'downloadable') {
                const url = URL.createObjectURL(blob);
                link.textContent = 'Download file';
                link.href = url;
                link.download = rcv.meta.name || 'file';
            } else {
                const url = URL.createObjectURL(blob);
                link.textContent = 'Open preview';
                link.href = 'javascript:void(0)';
                link.addEventListener('click', () => openPreviewModal(rcv.meta.name, url, rcv.meta.mime));
            }

            line.appendChild(link);
            parent.appendChild(line);

            updateProgressUI(id, 100);
            receivingTransfers.delete(id);
            console.log('File received completely:', id);
        }

        /* =======================
        Modal Preview (non-downloadable)
        ======================= */
        function openPreviewModal(name, url, mime){
            modalTitle.textContent = name || 'Preview';
            modalBody.innerHTML = '';

            if (mime && mime.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = url;
                img.alt = name || 'image';
                modalBody.appendChild(img);

                const backBtn = document.createElement('button');
                backBtn.className = 'inline-back';
                backBtn.textContent = 'Back';
                backBtn.style.marginTop = '8px';
                backBtn.addEventListener('click', closePreviewModal);
                modalBody.appendChild(backBtn);
            } else if (mime && mime.startsWith('video/')) {
                const vid = document.createElement('video');
                vid.src = url;
                vid.playsInline = true;
                vid.controls = false;
                vid.id = 'customVideo';
                modalBody.appendChild(vid);

                const controls = document.createElement('div');
                controls.className = 'player-controls';
                const btn = document.createElement('button');
                btn.textContent = 'Play';
                btn.addEventListener('click', () => {
                    if (vid.paused){
                        vid.play();
                        btn.textContent = 'Pause';
                    } else {
                        vid.pause();
                        btn.textContent = 'Play';
                    }
                });
                const seek = document.createElement('input');
                seek.type = 'range';
                seek.min = 0;
                seek.max = 1000;
                seek.value = 0;
                seek.addEventListener('input', () => {
                    if (vid.duration && isFinite(vid.duration)){
                        vid.currentTime = (seek.value/1000) * vid.duration;
                    }
                });
                vid.addEventListener('timeupdate', () => {
                    if (vid.duration && isFinite(vid.duration)){
                        seek.value = Math.floor((vid.currentTime / vid.duration) * 1000);
                    }
                });
                controls.appendChild(btn);
                controls.appendChild(seek);
                
                const backInside = document.createElement('button');
                backInside.className = 'inline-back';
                backInside.textContent = 'Back';
                backInside.addEventListener('click', closePreviewModal);
                controls.appendChild(backInside);
                
                modalBody.appendChild(controls);
            } else {
                const p = document.createElement('p');
                p.textContent = 'This preview only supports images and videos.';
                modalBody.appendChild(p);

                const backBtn = document.createElement('button');
                backBtn.className = 'inline-back';
                backBtn.textContent = 'Back';
                backBtn.style.marginTop = '8px';
                backBtn.addEventListener('click', closePreviewModal);
                modalBody.appendChild(backBtn);
            }

            modalBackdrop.style.display = 'flex';
            modalBackdrop.setAttribute('aria-hidden', 'false');
        }

        function closePreviewModal(){
            try {
                const vid = document.getElementById('customVideo');
                if (vid) {
                    vid.pause();
                    vid.src = '';
                }
            } catch(e){}
            modalBackdrop.style.display = 'none';
            modalBackdrop.setAttribute('aria-hidden', 'true');
            modalBody.innerHTML = '';
        }

        /* =======================
        Connection Actions
        ======================= */
        function connectToPeer(){
            const peerId = peerIdInput.value.trim();
            if (!peerId) return;
            if (!myUsername) {
                alert('Please set a username first');
                return;
            }
            updateConnectionStatus('connecting', 'Connecting...');
            connectedPeerId = peerId;
            const conn = peer.connect(peerId, { reliable: true });
            setupDataConnection(conn);
            connectButton.disabled = true;
        }

        function copyIdToClipboard(){
            const id = myIdElement.textContent;
            navigator.clipboard.writeText(id).then(() => {
                const original = copyIdButton.textContent;
                copyIdButton.textContent = 'Copied!';
                setTimeout(() => copyIdButton.textContent = original, 1500);
            });
        }

        function resetConnectionState(){
            messageInput.disabled = true;
            sendMessageButton.disabled = true;
            startStreamButton.disabled = true;
            stopStreamButton.disabled = true;
            connectButton.disabled = false;
            typingIndicator.style.visibility = 'hidden';
            endCall();
            stopStreaming();
            try {
                if (connection && connection.close) connection.close();
            } catch(e){}
            connection = null;
            dataChannel = null;
            connectedPeerId = null;
            peerUsername = '';
        }

        /* =======================
        Event Listeners
        ======================= */
        connectButton.addEventListener('click', connectToPeer);
        copyIdButton.addEventListener('click', copyIdToClipboard);
        sendMessageButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendMessage(); });
        messageInput.addEventListener('input', handleTyping);
        startVideoButton.addEventListener('click', startVideoCall);
        startVoiceButton.addEventListener('click', startVoiceCall);
        endCallButton.addEventListener('click', endCall);
        startStreamButton.addEventListener('click', startStreaming);
        stopStreamButton.addEventListener('click', stopStreaming);
        streamFileInput.addEventListener('change', () => { startStreamButton.disabled = !streamFileInput.files[0]; });

        // Username handling
        saveUsernameButton.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (username) {
                myUsername = username;
                usernameStatus.textContent = `Username: ${myUsername}`;
                usernameInput.disabled = true;
                saveUsernameButton.disabled = true;
            }
        });

        btnShareDownloadable.addEventListener('click', () => {
            pickDownloadable.click();
        });
        btnShareNonDownloadable.addEventListener('click', () => {
            alert('Non downloadable accepts only images and videos. They will open in a preview modal.');
            pickNonDownloadable.click();
        });

        pickDownloadable.addEventListener('change', () => {
            if (!dataChannel) return alert('Connect first');
            const files = Array.from(pickDownloadable.files || []);
            files.forEach(f => sendFileAsChunks(f, 'downloadable'));
            pickDownloadable.value = '';
        });
        pickNonDownloadable.addEventListener('change', () => {
            if (!dataChannel) return alert('Connect first');
            const files = Array.from(pickNonDownloadable.files || []);
            files.forEach(f => sendFileAsChunks(f, 'non-downloadable'));
            pickNonDownloadable.value = '';
        });

        const originalHandleDataMessage = handleDataMessage;
        function enhancedHandleDataMessage(obj){
            if (obj && obj.type === 'file-chunk' && obj.chunkB64) {
                handleFallbackChunkB64(obj);
                return;
            }
            originalHandleDataMessage(obj);
        }
        
        function setupDataChannel(){
            if (!dataChannel) return;
            dataChannel.on('data', enhancedHandleDataMessage);
            try { if (dataChannel._dc) dataChannel._dc.binaryType = 'arraybuffer'; } catch(e){}
        }

        /* =======================
        Initialize
        ======================= */
        initializePeer();
    </script>
</body>
</html>
