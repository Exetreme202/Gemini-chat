<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GEMINI CHAT AND SHARE</title>
  <style>
    /* Dark Theme Global Styles */
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: relative;
      min-height: 100vh;
    }
    h1 {
      margin-bottom: 20px;
    }
    /* Dark themed buttons, inputs and textareas */
    button, input, textarea {
      border-radius: 5px;
      margin: 5px;
      padding: 5px;
      background-color: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    /* Glow effects */
    .glow-green { box-shadow: 0 0 8px 2px green !important; }
    .glow-blue { box-shadow: 0 0 8px 2px blue !important; }
    .glow-red { box-shadow: 0 0 8px 2px red !important; }
    
    /* Main Tabs styling */
    #mainTabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      width: 100%;
      max-width: 800px;
      justify-content: center;
    }
    #mainTabs button {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
    }
    #mainTabs button.active {
      background: #444;
      font-weight: bold;
    }
    /* Join Stream Button */
    #joinStreamBtn {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
      margin-left: 10px;
      display: none;
    }
    
    .tab-content {
      border: 1px solid #555;
      padding: 10px;
      margin-bottom: 20px;
      width: 90%;
      max-width: 800px;
      background-color: #1e1e1e;
      border-radius: 10px;
    }
    /* Chat container: height adjusted and rounded */
    #chatLog {
      width: 300px;
      height: 200px;
      border: 1px solid #555;
      border-radius: 10px;
      overflow-y: auto;
      padding: 5px;
      background: #2a2a2a;
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin: 10px auto;
    }
    /* Center file transfer options in Chat tab */
    #chatInputContainer {
      margin-top: 10px;
      text-align: center;
    }
    /* Chat bubbles */
    .chat-bubble {
      display: inline-block;
      padding: 8px 12px;
      margin: 4px;
      border-radius: 15px;
      max-width: 50%;
      word-wrap: break-word;
    }
    .chat-bubble.me {
      background-color: #3a663a;
      align-self: flex-end;
    }
    .chat-bubble.peer {
      background-color: #2a4f6c;
      align-self: flex-start;
    }
    /* File link styling */
    .file-link a {
      text-decoration: none;
    }
    .file-link.me a { color: #8fbc8f; }
    .file-link.peer a { color: #6495ed; }
    /* QR Code container with white background and padding */
    #qrCodeContainer {
      margin-top: 10px;
      padding: 20px;
      background: #fff;
      color: #121212;
      display: inline-block;
      border-radius: 5px;
    }
    /* QR scanner container */
    #qr-reader {
      width: 300px;
      margin-top: 10px;
      display: none;
    }
    /* Call/Stream sub-tabs - centered and same size */
    #callStreamTabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      justify-content: center;
    }
    #callStreamTabs button {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid #555;
      background: #333;
      width: 100px;
    }
    #callStreamTabs button.active {
      background: #444;
      font-weight: bold;
    }
    /* Containers for Call and Stream features */
    #callContainer, #streamContainer {
      border: 1px solid #555;
      padding: 10px;
      margin: 10px 0;
      background-color: #1e1e1e;
      border-radius: 10px;
    }
    /* Video Call container */
    #videoCallContainer {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: auto;
    }
    #videoCallContainer .remote-video {
      width: 100%;
      height: auto;
      background: black;
    }
    #videoCallContainer .local-video {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 30%;
      border: 2px solid #444;
      box-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    /* Footer */
    footer {
      font-size: 10px;
      margin-top: auto;
      padding: 5px;
      color: #888;
    }
    /* Status indicators */
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }
    .status-connected {
      background-color: green;
    }
    .status-disconnected {
      background-color: red;
    }
    .status-connecting {
      background-color: orange;
    }
    /* Progress bar for file transfers */
    .progress-container {
      width: 100%;
      background-color: #333;
      border-radius: 5px;
      margin: 5px 0;
    }
    .progress-bar {
      height: 10px;
      background-color: #4caf50;
      border-radius: 5px;
      width: 0%;
      transition: width 0.3s;
    }
  </style>
  <!-- Required libraries -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode@2.3.4/minified/html5-qrcode.min.js"></script>
</head>
<body>
  <h1>GEMINI CHAT AND SHARE</h1>
  <!-- Connection status -->
  <div id="connectionStatus"><span class="status-indicator status-disconnected"></span>Disconnected</div>

  <!-- Main Tabs -->
  <div id="mainTabs">
    <button id="mainTabConnection" class="active">Connection</button>
    <button id="mainTabChat">Chat &amp; Share</button>
    <button id="mainTabCallStream">Call/Stream</button>
    <button id="joinStreamBtn" class="glow-blue">Join Stream</button>
  </div>

  <!-- Connection Tab Content -->
  <div id="tabContentConnection" class="tab-content">
    <div id="automaticSignaling">
      <h2>PeerJS Signaling</h2>
      <button id="createRoomBtn">Create Room</button>
      <button id="copyRoomIdBtn">Copy Room ID</button>
      <br>
      <input type="text" id="roomIdInput" placeholder="Room ID">
      <button id="joinRoomBtn">Join Room</button>
      <div id="peerStatus"></div>
      <div id="qrCodeContainer"></div>
      <button id="scanQRCodeBtn">Scan QR Code</button>
      <button id="closeScannerBtn" style="display:none;">Close Scanner</button>
      <div id="qr-reader"></div>
    </div>
  </div>

  <!-- Chat & Share Tab Content -->
  <div id="tabContentChat" class="tab-content" style="display:none;">
    <section id="chat-section">
      <h2>Chat and File Transfer</h2>
      <div id="chatLog"></div>
      <div id="chatInputContainer">
        <input type="text" id="chatInput" placeholder="Type a message...">
        <button id="sendChatBtn">Send Chat</button>
        <div style="display: flex; justify-content: center; align-items: center; flex-direction: column;">
          <input type="file" id="fileInput">
          <button id="sendFileBtn">Send File</button>
          <div id="fileProgressContainer" class="progress-container" style="display: none;">
            <div id="fileProgressBar" class="progress-bar"></div>
          </div>
          <button id="cancelFileTransferBtn" style="display:none;">Cancel Transfer</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Call/Stream Tab Content -->
  <div id="tabContentCallStream" class="tab-content" style="display:none;">
    <div id="callStreamTabs">
      <button id="subTabCall" class="active">Call</button>
      <button id="subTabStream">Stream</button>
    </div>
    <div id="callSubContent">
      <!-- Call Features -->
      <div id="callContainer">
        <!-- Video Call Section -->
        <div id="videoCallSection">
          <h2>Video Call</h2>
          <button id="startVideoCallBtn">Start Video Call</button>
          <button id="endCallBtn" style="display:none;">End Video Call</button>
          <div id="videoCallContainer" style="display:none;">
            <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
            <video id="localVideo" class="local-video" autoplay muted playsinline></video>
          </div>
        </div>
      </div>
      <!-- Stream Features -->
      <div id="streamContainer" style="display:none;">
        <!-- Video Streaming Section -->
        <div id="videoStreamSection">
          <h2>Video Streaming</h2>
          <p><strong>Select a video file to stream:</strong></p>
          <input type="file" id="videoFileInput" accept="video/*">
          <button id="startVideoStreamBtn">Start Video Stream</button>
          <button id="endStreamBtn" style="display:none;">End Video Stream</button>
          <br>
          <p><strong>Local Stream (Sender's Playback):</strong></p>
          <video id="localStreamedVideo" controls playsinline style="width:300px; display:none;"></video>
          <p><strong>Remote Stream (Receiver's Playback):</strong></p>
          <video id="remoteStreamedVideo" autoplay playsinline style="width:300px; display:none;"></video>
          <br>
          <button id="enterFullscreenBtn" style="display:none;">Full Screen Mode</button>
          <button id="exitFullscreenBtn" style="display:none;">Exit Full Screen</button>
        </div>
      </div>
    </div>
  </div>

  <footer>Developed by Jijo.</footer>

  <script>
    /***** Global Variables *****/
    let currentMainTab = "connection";
    let currentSubTab = "call";
    let isOfferer = false;
    let dataPeer = null; // For data channel (chat, file transfer, and signaling)
    let mediaPeer = null; // Dedicated for media streaming and calls
    let dataChannel = null;
    let fileReceiver = null;
    let fileSender = null;
    let peer = null;
    let signalingConn = null;
    let isStreamSender = false;
    let isInCall = false;

    let html5QrCodeScannerInstance = null;

    // ICE candidate buffers
    const dataIceBuffer = [];
    const mediaIceBuffer = [];
    let dataRemoteDescriptionSet = false;
    let mediaRemoteDescriptionSet = false;

    /***** ICE Servers Configuration *****/
    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' }
    ];

    /***** Tab Switching Functions *****/
    function switchMainTab(tabName) {
      document.getElementById("tabContentConnection").style.display = "none";
      document.getElementById("tabContentChat").style.display = "none";
      document.getElementById("tabContentCallStream").style.display = "none";
      document.getElementById("mainTabConnection").classList.remove("active", "glow-red", "glow-green");
      document.getElementById("mainTabChat").classList.remove("active", "glow-green");
      document.getElementById("mainTabCallStream").classList.remove("active", "glow-green");
      
      if(tabName === "connection") {
        document.getElementById("tabContentConnection").style.display = "block";
        document.getElementById("mainTabConnection").classList.add("active");
      } else if(tabName === "chat") {
        document.getElementById("tabContentChat").style.display = "block";
        document.getElementById("mainTabChat").classList.add("active");
      } else if(tabName === "callstream") {
        document.getElementById("tabContentCallStream").style.display = "block";
        document.getElementById("mainTabCallStream").classList.add("active");
      }
      
      currentMainTab = tabName;
      if(tabName === "callstream") {
        document.getElementById("joinStreamBtn").style.display = "none";
      }
    }

    function switchCallStreamSubTab(tabName) {
      document.getElementById("callContainer").style.display = "none";
      document.getElementById("streamContainer").style.display = "none";
      document.getElementById("subTabCall").classList.remove("active", "glow-green");
      document.getElementById("subTabStream").classList.remove("active", "glow-green");
      
      if(tabName === "call") {
        document.getElementById("callContainer").style.display = "block";
        document.getElementById("subTabCall").classList.add("active");
      } else if(tabName === "stream") {
        document.getElementById("streamContainer").style.display = "block";
        document.getElementById("subTabStream").classList.add("active");
      }
      
      currentSubTab = tabName;
    }

    /***** Utility Functions *****/
    function updateConnectionStatus(status) {
      const elem = document.getElementById("connectionStatus");
      const indicator = elem.querySelector('.status-indicator');
      elem.innerHTML = '';
      
      if (status.toLowerCase() === "connected") {
        indicator.className = 'status-indicator status-connected';
        elem.appendChild(indicator);
        elem.appendChild(document.createTextNode("Connected"));
        document.getElementById("mainTabConnection").classList.remove("glow-red");
      } else if (status.toLowerCase() === "connecting") {
        indicator.className = 'status-indicator status-connecting';
        elem.appendChild(indicator);
        elem.appendChild(document.createTextNode("Connecting"));
      } else if (status.toLowerCase() === "disconnected") {
        indicator.className = 'status-indicator status-disconnected';
        elem.appendChild(indicator);
        elem.appendChild(document.createTextNode("Disconnected"));
        document.getElementById("mainTabConnection").classList.add("glow-red");
      } else {
        indicator.className = 'status-indicator status-disconnected';
        elem.appendChild(indicator);
        elem.appendChild(document.createTextNode(status));
      }
      
      elem.style.fontWeight = "bold";
    }
    
    function logChat(message, sender) {
      const chatLog = document.getElementById("chatLog");
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      
      if(sender === "me") {
        bubble.classList.add("me");
      } else if(sender === "peer") {
        bubble.classList.add("peer");
      } else {
        bubble.style.backgroundColor = "#555";
        bubble.style.alignSelf = "center";
      }
      
      bubble.innerText = message;
      chatLog.appendChild(bubble);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    
    function logFileBubble(linkElement, sender) {
      const chatLog = document.getElementById("chatLog");
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      
      if(sender === "me") {
        bubble.classList.add("me");
      } else {
        bubble.classList.add("peer");
      }
      
      bubble.appendChild(linkElement);
      chatLog.appendChild(bubble);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    
    function clearTabIndicators() {
      document.getElementById("mainTabChat").classList.remove("glow-green");
      document.getElementById("mainTabCallStream").classList.remove("glow-green");
      document.getElementById("subTabStream").classList.remove("glow-green");
    }

    /***** Setup for Data Connection *****/
    function setupDataConnection() {
      dataPeer = new RTCPeerConnection({ iceServers });
      
      // Buffer ICE candidates until remote description is set
      dataPeer.onicecandidate = event => {
        if (event.candidate) {
          if (signalingConn && signalingConn.open) {
            signalingConn.send(JSON.stringify({ 
              type: "data-candidate", 
              candidate: event.candidate 
            }));
          }
        }
      };
      
      if (isOfferer) {
        dataChannel = dataPeer.createDataChannel("chat");
        setupDataChannel();
      } else {
        dataPeer.ondatachannel = event => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }
    }
    
    function setupDataChannel() {
      dataChannel.onopen = () => {
        logChat("Data channel open.", "system");
        updateConnectionStatus("Connected");
        switchMainTab("chat");
      };
      
      dataChannel.onclose = () => { 
        updateConnectionStatus("Disconnected"); 
        logChat("Data channel closed.", "system");
      };
      
      dataChannel.onerror = (error) => {
        console.error("Data channel error:", error);
        logChat("Data channel error occurred.", "system");
      };
      
      dataChannel.onmessage = event => {
        try {
          const msg = JSON.parse(event.data);
          handleDataChannelMessage(msg);
        } catch (e) {
          handleFileChunk(event.data);
        }
      };
    }

    /***** Setup for Media Connection *****/
    function setupMediaConnection() {
      mediaPeer = new RTCPeerConnection({ iceServers });
      
      mediaPeer.onicecandidate = event => {
        if (event.candidate && dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(JSON.stringify({ 
            type: "media-candidate", 
            candidate: event.candidate 
          }));
        }
      };
      
      mediaPeer.ontrack = event => {
        if (event.streams && event.streams[0]) {
          if (event.track.kind === "video") {
            document.getElementById("remoteVideo").srcObject = event.streams[0];
            document.getElementById("remoteStreamedVideo").srcObject = event.streams[0];
            document.getElementById("remoteStreamedVideo").style.display = "block";
            document.getElementById("enterFullscreenBtn").style.display = "inline";
          }
        }
      };
      
      mediaPeer.onconnectionstatechange = () => {
        console.log("Media connection state:", mediaPeer.connectionState);
        if (mediaPeer.connectionState === "disconnected" || 
            mediaPeer.connectionState === "failed") {
          if (isInCall) {
            endVideoCall();
          }
          if (isStreamSender) {
            endVideoStream();
          }
        }
      };
    }

    /***** PeerJS Signaling *****/
    function sendSignalingMessage(msg) {
      if (signalingConn && signalingConn.open) {
        signalingConn.send(JSON.stringify(msg));
      }
    }
    
    function handleSignalingMessage(msg) {
      switch (msg.type) {
        case "data-offer":
          isOfferer = false;
          setupDataConnection();
          setupMediaConnection();
          
          dataPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp))
            .then(async () => {
              dataRemoteDescriptionSet = true;
              
              // Process buffered ICE candidates
              while (dataIceBuffer.length > 0) {
                const candidate = dataIceBuffer.shift();
                await dataPeer.addIceCandidate(new RTCIceCandidate(candidate));
              }
              
              const answer = await dataPeer.createAnswer();
              await dataPeer.setLocalDescription(answer);
              sendSignalingMessage({ type: "data-answer", sdp: dataPeer.localDescription });
            })
            .catch(error => {
              console.error("Error setting remote description:", error);
            });
          break;
          
        case "data-answer":
          dataPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp))
            .then(() => {
              dataRemoteDescriptionSet = true;
              
              // Process buffered ICE candidates
              while (dataIceBuffer.length > 0) {
                const candidate = dataIceBuffer.shift();
                dataPeer.addIceCandidate(new RTCIceCandidate(candidate));
              }
            })
            .catch(error => {
              console.error("Error setting remote description:", error);
            });
          break;
          
        case "data-candidate":
          const candidate = new RTCIceCandidate(msg.candidate);
          if (dataRemoteDescriptionSet) {
            dataPeer.addIceCandidate(candidate)
              .catch(error => {
                console.error("Error adding ICE candidate:", error);
              });
          } else {
            dataIceBuffer.push(candidate);
          }
          break;
          
        default:
          console.log("Unknown signaling message:", msg.type);
      }
    }

    /***** Automatic Signaling (PeerJS) *****/
    function initializePeerConnection() {
      peer = new Peer({
        debug: 3,
        config: { iceServers }
      });
      
      peer.on('open', id => {
        document.getElementById("roomIdInput").value = id;
        document.getElementById("peerStatus").innerText = "Room created with ID: " + id;
        isOfferer = true;
        
        const qrContainer = document.getElementById("qrCodeContainer");
        qrContainer.innerHTML = "";
        new QRCode(qrContainer, {
          text: id,
          width: 128,
          height: 128,
          colorDark: "#121212",
          colorLight: "#fff",
          correctLevel: QRCode.CorrectLevel.H
        });
      });
      
      peer.on('connection', conn => {
        signalingConn = conn;
        
        signalingConn.on('data', data => { 
          handleSignalingMessage(JSON.parse(data)); 
        });
        
        signalingConn.on('open', () => {
          document.getElementById("peerStatus").innerText += " – Signaling connection established.";
          updateConnectionStatus("Connecting");
          
          setupDataConnection();
          setupMediaConnection();
          
          dataPeer.createOffer()
            .then(offer => dataPeer.setLocalDescription(offer))
            .then(() => {
              sendSignalingMessage({ type: "data-offer", sdp: dataPeer.localDescription });
            })
            .catch(error => {
              console.error("Error creating data offer:", error);
            });
        });
        
        signalingConn.on('close', () => {
          logChat("Signaling connection closed.", "system");
          updateConnectionStatus("Disconnected");
        });
        
        signalingConn.on('error', (error) => {
          console.error("Signaling connection error:", error);
          logChat("Signaling error occurred.", "system");
        });
      });
      
      peer.on('error', error => {
        console.error('PeerJS error:', error);
        updateConnectionStatus("Failed connecting");
        logChat("Connection error: " + error.type, "system");
      });
      
      peer.on('disconnected', () => {
        logChat("Peer disconnected.", "system");
        updateConnectionStatus("Disconnected");
      });
      
      peer.on('close', () => {
        logChat("Peer connection closed.", "system");
        updateConnectionStatus("Disconnected");
      });
    }

    document.getElementById("createRoomBtn").onclick = () => {
      if (peer) {
        peer.destroy();
      }
      initializePeerConnection();
    };
    
    document.getElementById("copyRoomIdBtn").onclick = () => {
      const roomId = document.getElementById("roomIdInput").value;
      navigator.clipboard.writeText(roomId)
        .then(() => {
          logChat("Room ID copied to clipboard.", "system");
        })
        .catch(error => {
          console.error("Failed to copy room ID:", error);
        });
    };
    
    document.getElementById("joinRoomBtn").onclick = () => {
      const roomId = document.getElementById("roomIdInput").value;
      if (!roomId) {
        alert("Please enter a Room ID to join.");
        return;
      }
      
      if (peer) {
        peer.destroy();
      }
      
      peer = new Peer({
        debug: 3,
        config: { iceServers }
      });
      
      peer.on('open', id => {
        document.getElementById("peerStatus").innerText = "Your PeerJS ID: " + id;
        signalingConn = peer.connect(roomId);
        
        signalingConn.on('open', () => {
          document.getElementById("peerStatus").innerText += " – Connected to room " + roomId;
          updateConnectionStatus("Connecting");
        });
        
        signalingConn.on('data', data => { 
          handleSignalingMessage(JSON.parse(data)); 
        });
        
        signalingConn.on('close', () => {
          logChat("Signaling connection closed.", "system");
          updateConnectionStatus("Disconnected");
        });
        
        signalingConn.on('error', (error) => {
          console.error("Signaling connection error:", error);
          logChat("Signaling error occurred.", "system");
        });
      });
      
      peer.on('error', error => {
        console.error('PeerJS error:', error);
        updateConnectionStatus("Failed connecting");
        logChat("Connection error: " + error.type, "system");
      });
      
      updateConnectionStatus("Connecting");
    };

    /***** QR Code Scanning using Html5Qrcode *****/
    function startQrScanner() {
      const qrReaderElem = document.getElementById("qr-reader");
      qrReaderElem.style.display = "block";
      
      html5QrCodeScannerInstance = new Html5Qrcode("qr-reader");
      const config = { fps: 10, qrbox: 250 };
      
      html5QrCodeScannerInstance.start(
        { facingMode: "environment" },
        config,
        (decodedText, decodedResult) => {
          console.log("QR Code detected: ", decodedText);
          document.getElementById("roomIdInput").value = decodedText;
          
          html5QrCodeScannerInstance.stop().then(() => {
            qrReaderElem.style.display = "none";
            document.getElementById("closeScannerBtn").style.display = "none";
            document.getElementById("scanQRCodeBtn").style.display = "inline";
            document.getElementById("joinRoomBtn").click();
          }).catch(err => {
            console.error("Failed to stop scanner: ", err);
          });
        },
        errorMessage => {
          console.log("QR scan error: ", errorMessage);
        }
      ).catch(err => {
        console.error("Unable to start scanning.", err);
      });
    }
    
    document.getElementById("scanQRCodeBtn").onclick = function() {
      startQrScanner();
      this.style.display = "none";
      document.getElementById("closeScannerBtn").style.display = "inline";
    };
    
    document.getElementById("closeScannerBtn").onclick = function() {
      if (html5QrCodeScannerInstance) {
        html5QrCodeScannerInstance.stop().then(() => {
          document.getElementById("qr-reader").style.display = "none";
          html5QrCodeScannerInstance = null;
          this.style.display = "none";
          document.getElementById("scanQRCodeBtn").style.display = "inline";
        }).catch(err => {
          console.error("Error stopping QR scanner: ", err);
        });
      }
    };

    /***** Data Channel Message Handling *****/
    function handleDataChannelMessage(msg) {
      switch (msg.type) {
        case "chat":
          logChat(msg.message, "peer");
          if(currentMainTab !== "chat") {
            document.getElementById("mainTabChat").classList.add("glow-green");
          }
          break;
          
        case "file-meta":
          if (fileReceiver) {
            logChat("Already receiving a file. Please wait.", "system");
            return;
          }
          
          fileReceiver = {
            name: msg.name,
            size: msg.size,
            type: msg.fileType,
            received: [],
            receivedSize: 0
          };
          
          const progressElem = document.createElement("div");
          progressElem.innerHTML = `
            <div>Receiving file: ${msg.name}</div>
            <div class="progress-container">
              <div class="progress-bar" style="width: 0%"></div>
            </div>
          `;
          progressElem.classList.add("chat-bubble", "peer");
          document.getElementById("chatLog").appendChild(progressElem);
          
          if(currentMainTab !== "chat") {
            document.getElementById("mainTabChat").classList.add("glow-green");
          }
          break;
          
        case "file-cancel":
          if (fileReceiver) {
            logChat("File transfer canceled by sender.", "system");
            fileReceiver = null;
            
            // Remove progress indicator
            const chatLog = document.getElementById("chatLog");
            const lastChild = chatLog.lastChild;
            if (lastChild && lastChild.classList.contains("chat-bubble")) {
              chatLog.removeChild(lastChild);
            }
          }
          break;
          
        case "media-offer":
          if (!mediaPeer) {
            setupMediaConnection();
          }
          
          mediaPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp))
            .then(async () => {
              mediaRemoteDescriptionSet = true;
              
              // Process buffered ICE candidates
              while (mediaIceBuffer.length > 0) {
                const candidate = mediaIceBuffer.shift();
                await mediaPeer.addIceCandidate(new RTCIceCandidate(candidate));
              }
              
              const answer = await mediaPeer.createAnswer();
              await mediaPeer.setLocalDescription(answer);
              
              if (dataChannel && dataChannel.readyState === "open") {
                dataChannel.send(JSON.stringify({ 
                  type: "media-answer", 
                  sdp: mediaPeer.localDescription 
                }));
              }
            })
            .catch(error => {
              console.error("Error setting remote media description:", error);
            });
          break;
          
        case "media-answer":
          mediaPeer.setRemoteDescription(new RTCSessionDescription(msg.sdp))
            .then(() => {
              mediaRemoteDescriptionSet = true;
              
              // Process buffered ICE candidates
              while (mediaIceBuffer.length > 0) {
                const candidate = mediaIceBuffer.shift();
                mediaPeer.addIceCandidate(new RTCIceCandidate(candidate));
              }
            })
            .catch(error => {
              console.error("Error setting remote media description:", error);
            });
          break;
          
        case "media-candidate":
          const candidate = new RTCIceCandidate(msg.candidate);
          if (mediaRemoteDescriptionSet) {
            mediaPeer.addIceCandidate(candidate)
              .catch(error => {
                console.error("Error adding media ICE candidate:", error);
              });
          } else {
            mediaIceBuffer.push(candidate);
          }
          break;
          
        case "call-request":
          if (confirm("Incoming video call from peer. Accept call?")) {
            dataChannel.send(JSON.stringify({ type: "call-response", accepted: true }));
            switchMainTab("callstream");
            switchCallStreamSubTab("call");
            prepareVideoCall();
          } else {
            dataChannel.send(JSON.stringify({ type: "call-response", accepted: false }));
          }
          break;
          
        case "call-response":
          if (msg.accepted) {
            startVideoCall();
          } else {
            alert("Your video call request was rejected.");
            document.getElementById("startVideoCallBtn").disabled = false;
          }
          break;
          
        case "stream-offer":
          handleStreamOffer(msg.sdp);
          if(currentMainTab !== "callstream" || currentSubTab !== "stream") {
            document.getElementById("mainTabCallStream").classList.add("glow-green");
            document.getElementById("subTabStream").classList.add("glow-green");
            document.getElementById("joinStreamBtn").style.display = "inline";
          }
          break;
          
        case "end-stream":
          document.getElementById("remoteStreamedVideo").srcObject = null;
          document.getElementById("remoteStreamedVideo").style.display = "none";
          document.getElementById("enterFullscreenBtn").style.display = "none";
          logChat("Video stream ended by peer.", "peer");
          break;
          
        case "end-call":
          endVideoCall();
          logChat("Video call ended by peer.", "peer");
          break;
          
        default:
          console.log("Unknown message type:", msg.type);
      }
    }

    /***** Combined Chat & File Transfer *****/
    document.getElementById("sendChatBtn").onclick = () => {
      const input = document.getElementById("chatInput");
      const text = input.value.trim();
      
      if (!text) return;
      
      if (dataChannel && dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({ type: "chat", message: text }));
        logChat(text, "me");
        input.value = "";
      } else {
        logChat("Data channel is not ready. Please check connection.", "system");
      }
    };
    
    document.getElementById("chatInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        document.getElementById("sendChatBtn").click();
      }
    });
    
    document.getElementById("sendFileBtn").onclick = () => {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      
      if (!file) {
        alert("Please select a file first.");
        return;
      }
      
      if (!dataChannel || dataChannel.readyState !== "open") {
        alert("Data channel is not ready. Please check connection.");
        return;
      }
      
      if (fileSender) {
        alert("A file transfer is already in progress.");
        return;
      }
      
      // Show progress UI
      document.getElementById("fileProgressContainer").style.display = "block";
      document.getElementById("fileProgressBar").style.width = "0%";
      document.getElementById("cancelFileTransferBtn").style.display = "inline";
      document.getElementById("sendFileBtn").disabled = true;
      
      // Send file metadata
      dataChannel.send(JSON.stringify({ 
        type: "file-meta", 
        name: file.name, 
        size: file.size, 
        fileType: file.type 
      }));
      
      let offset = 0;
      const chunkSize = 16384; // 16KB chunks
      const reader = new FileReader();
      
      fileSender = {
        file: file,
        offset: offset,
        reader: reader,
        cancelled: false
      };
      
      reader.onload = e => {
        if (fileSender.cancelled) {
          return;
        }
        
        try {
          dataChannel.send(e.target.result);
          offset += e.target.result.byteLength;
          
          // Update progress
          const progress = Math.floor((offset / file.size) * 100);
          document.getElementById("fileProgressBar").style.width = progress + "%";
          
          if (offset < file.size) {
            readNextChunk();
          } else {
            // Transfer complete
            document.getElementById("fileProgressContainer").style.display = "none";
            document.getElementById("cancelFileTransferBtn").style.display = "none";
            document.getElementById("sendFileBtn").disabled = false;
            fileInput.value = "";
            fileSender = null;
            logChat(`File "${file.name}" sent successfully.`, "me");
          }
        } catch (error) {
          console.error("Error sending file chunk:", error);
          logChat("File transfer failed.", "system");
          cancelFileTransfer();
        }
      };
      
      reader.onerror = () => {
        console.error("File reading error");
        logChat("File transfer failed.", "system");
        cancelFileTransfer();
      };
      
      const readNextChunk = () => {
        if (fileSender.cancelled) {
          return;
        }
        
        const slice = file.slice(offset, offset + chunkSize);
        reader.readAsArrayBuffer(slice);
      };
      
      readNextChunk();
    };
    
    document.getElementById("cancelFileTransferBtn").onclick = () => {
      cancelFileTransfer();
    };
    
    function cancelFileTransfer() {
      if (fileSender) {
        fileSender.cancelled = true;
        
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(JSON.stringify({ type: "file-cancel" }));
        }
        
        document.getElementById("fileProgressContainer").style.display = "none";
        document.getElementById("cancelFileTransferBtn").style.display = "none";
        document.getElementById("sendFileBtn").disabled = false;
        fileSender = null;
        logChat("File transfer cancelled.", "system");
      }
    }
    
    function handleFileChunk(chunk) {
      if (!fileReceiver) return;
      
      fileReceiver.received.push(chunk);
      fileReceiver.receivedSize += chunk.byteLength;
      
      // Update progress UI
      const progress = Math.floor((fileReceiver.receivedSize / fileReceiver.size) * 100);
      const progressBars = document.querySelectorAll(".progress-bar");
      if (progressBars.length > 0) {
        progressBars[progressBars.length - 1].style.width = progress + "%";
      }
      
      if (fileReceiver.receivedSize >= fileReceiver.size) {
        // File transfer complete
        const blob = new Blob(fileReceiver.received, { type: fileReceiver.type });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = fileReceiver.name;
        link.innerText = fileReceiver.name;
        link.classList.add("file-link", "peer");
        
        // Replace progress indicator with download link
        const chatLog = document.getElementById("chatLog");
        const lastChild = chatLog.lastChild;
        if (lastChild && lastChild.classList.contains("chat-bubble")) {
          chatLog.removeChild(lastChild);
        }
        
        logFileBubble(link, "peer");
        fileReceiver = null;
      }
    }

    /***** Video Call Functions *****/
    document.getElementById("startVideoCallBtn").onclick = () => {
      if (!dataChannel || dataChannel.readyState !== "open") {
        alert("Data channel is not open.");
        return;
      }
      
      document.getElementById("startVideoCallBtn").disabled = true;
      dataChannel.send(JSON.stringify({ type: "call-request" }));
      
      // Timeout if no response
      setTimeout(() => {
        if (!isInCall) {
          document.getElementById("startVideoCallBtn").disabled = false;
          alert("No response from peer. Call timed out.");
        }
      }, 30000);
    };
    
    async function prepareVideoCall() {
      if (isInCall) return;
      
      try {
        const localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        
        document.getElementById("localVideo").srcObject = localStream;
        document.getElementById("videoCallContainer").style.display = "block";
        document.getElementById("endCallBtn").style.display = "inline";
        
        // Add tracks to media connection
        localStream.getTracks().forEach(track => {
          mediaPeer.addTrack(track, localStream);
        });
        
        // Create and send offer
        const offer = await mediaPeer.createOffer();
        await mediaPeer.setLocalDescription(offer);
        
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(JSON.stringify({ 
            type: "media-offer", 
            sdp: mediaPeer.localDescription 
          }));
        }
        
        isInCall = true;
      } catch (error) {
        console.error("Error starting video call:", error);
        logChat("Failed to access camera/microphone.", "system");
        document.getElementById("startVideoCallBtn").disabled = false;
      }
    }
    
    async function startVideoCall() {
      if (isInCall) return;
      
      try {
        const localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        
        document.getElementById("localVideo").srcObject = localStream;
        document.getElementById("videoCallContainer").style.display = "block";
        document.getElementById("endCallBtn").style.display = "inline";
        document.getElementById("startVideoCallBtn").disabled = false;
        
        // Add tracks to media connection
        localStream.getTracks().forEach(track => {
          mediaPeer.addTrack(track, localStream);
        });
        
        isInCall = true;
      } catch (error) {
        console.error("Error starting video call:", error);
        logChat("Failed to access camera/microphone.", "system");
        document.getElementById("startVideoCallBtn").disabled = false;
      }
    }
    
    document.getElementById("endCallBtn").onclick = () => {
      endVideoCall();
      
      if (dataChannel && dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({ type: "end-call" }));
      }
    };
    
    function endVideoCall() {
      if (!isInCall) return;
      
      // Stop all tracks
      if (document.getElementById("localVideo").srcObject) {
        document.getElementById("localVideo").srcObject.getTracks().forEach(track => track.stop());
        document.getElementById("localVideo").srcObject = null;
      }
      
      document.getElementById("remoteVideo").srcObject = null;
      document.getElementById("videoCallContainer").style.display = "none";
      document.getElementById("endCallBtn").style.display = "none";
      
      // Remove all tracks from media connection
      if (mediaPeer) {
        mediaPeer.getSenders().forEach(sender => {
          if (sender.track) {
            sender.track.stop();
          }
        });
      }
      
      isInCall = false;
      logChat("Video call ended.", "me");
    }

    /***** Video Streaming Functions *****/
    document.getElementById("startVideoStreamBtn").onclick = async () => {
      if (!dataChannel || dataChannel.readyState !== "open") {
        alert("Data channel is not open.");
        return;
      }
      
      const fileInput = document.getElementById("videoFileInput");
      const file = fileInput.files[0];
      
      if (!file) {
        alert("Please select a video file first.");
        return;
      }
      
      isStreamSender = true;
      document.getElementById("startVideoStreamBtn").disabled = true;
      document.getElementById("endStreamBtn").style.display = "inline";
      
      const localStreamedVideo = document.getElementById("localStreamedVideo");
      localStreamedVideo.style.display = "block";
      
      if (localStreamedVideo.srcObject) {
        localStreamedVideo.srcObject.getTracks().forEach(track => track.stop());
      }
      
      const fileURL = URL.createObjectURL(file);
      localStreamedVideo.src = fileURL;
      localStreamedVideo.muted = true;
      localStreamedVideo.load();
      
      localStreamedVideo.onloadedmetadata = async () => {
        try {
          await localStreamedVideo.play();
          const stream = localStreamedVideo.captureStream();
          
          // Add tracks to media connection
          stream.getTracks().forEach(track => {
            mediaPeer.addTrack(track, stream);
          });
          
          // Create and send offer
          const offer = await mediaPeer.createOffer();
          await mediaPeer.setLocalDescription(offer);
          
          if (dataChannel && dataChannel.readyState === "open") {
            dataChannel.send(JSON.stringify({ 
              type: "stream-offer", 
              sdp: mediaPeer.localDescription 
            }));
          }
        } catch (error) {
          console.error("Error starting video stream:", error);
          logChat("Failed to start video stream.", "system");
          endVideoStream();
        }
      };
      
      localStreamedVideo.onerror = () => {
        console.error("Error loading video");
        logChat("Failed to load video file.", "system");
        endVideoStream();
      };
    };
    
    async function handleStreamOffer(sdp) {
      if (!mediaPeer) {
        setupMediaConnection();
      }
      
      try {
        await mediaPeer.setRemoteDescription(new RTCSessionDescription(sdp));
        mediaRemoteDescriptionSet = true;
        
        // Process buffered ICE candidates
        while (mediaIceBuffer.length > 0) {
          const candidate = mediaIceBuffer.shift();
          await mediaPeer.addIceCandidate(new RTCIceCandidate(candidate));
        }
        
        const answer = await mediaPeer.createAnswer();
        await mediaPeer.setLocalDescription(answer);
        
        if (dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(JSON.stringify({ 
            type: "media-answer", 
            sdp: mediaPeer.localDescription 
          }));
        }
      } catch (error) {
        console.error("Error handling stream offer:", error);
      }
    }
    
    document.getElementById("endStreamBtn").onclick = () => {
      endVideoStream();
      
      if (dataChannel && dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({ type: "end-stream" }));
      }
    };
    
    function endVideoStream() {
      const localStreamedVideo = document.getElementById("localStreamedVideo");
      if (localStreamedVideo.srcObject) {
        localStreamedVideo.srcObject.getTracks().forEach(track => track.stop());
        localStreamedVideo.srcObject = null;
      }
      
      localStreamedVideo.style.display = "none";
      document.getElementById("remoteStreamedVideo").srcObject = null;
      document.getElementById("remoteStreamedVideo").style.display = "none";
      document.getElementById("endStreamBtn").style.display = "none";
      document.getElementById("startVideoStreamBtn").disabled = false;
      document.getElementById("enterFullscreenBtn").style.display = "none";
      
      // Remove all tracks from media connection
      if (mediaPeer) {
        mediaPeer.getSenders().forEach(sender => {
          if (sender.track) {
            sender.track.stop();
          }
        });
      }
      
      isStreamSender = false;
      logChat("Video stream ended.", "me");
    }

    /***** Full Screen Controls *****/
    document.getElementById("enterFullscreenBtn").onclick = async () => {
      const remoteStreamedVideo = document.getElementById("remoteStreamedVideo");
      
      if (remoteStreamedVideo.requestFullscreen) {
        await remoteStreamedVideo.requestFullscreen();
        document.getElementById("enterFullscreenBtn").style.display = "none";
        document.getElementById("exitFullscreenBtn").style.display = "inline";
      }
    };
    
    document.getElementById("exitFullscreenBtn").onclick = async () => {
      if (document.exitFullscreen) {
        await document.exitFullscreen();
        document.getElementById("enterFullscreenBtn").style.display = "inline";
        document.getElementById("exitFullscreenBtn").style.display = "none";
      }
    };
    
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        document.getElementById("enterFullscreenBtn").style.display = "inline";
        document.getElementById("exitFullscreenBtn").style.display = "none";
      }
    });

    /***** Join Stream Button Functionality *****/
    document.getElementById("joinStreamBtn").onclick = () => {
      document.getElementById("joinStreamBtn").style.display = "none";
      switchMainTab("callstream");
      switchCallStreamSubTab("stream");
      clearTabIndicators();
    };

    /***** Initialize Event Listeners *****/
    function initializeEventListeners() {
      // Main tab switching
      document.getElementById("mainTabConnection").addEventListener("click", () => { 
        switchMainTab("connection"); 
        clearTabIndicators();
      });
      document.getElementById("mainTabChat").addEventListener("click", () => { 
        switchMainTab("chat"); 
        clearTabIndicators();
      });
      document.getElementById("mainTabCallStream").addEventListener("click", () => { 
        switchMainTab("callstream"); 
        clearTabIndicators();
      });
      
      // Sub tab switching
      document.getElementById("subTabCall").addEventListener("click", () => { 
        switchCallStreamSubTab("call"); 
        clearTabIndicators();
      });
      document.getElementById("subTabStream").addEventListener("click", () => { 
        switchCallStreamSubTab("stream"); 
        clearTabIndicators();
      });
      
      // Initialize app
      updateConnectionStatus("Disconnected");
    }
    
    // Initialize when page loads
    window.addEventListener('load', initializeEventListeners);
  </script>
</body>
</html>
