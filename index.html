<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simple WebRTC Chat (Upgraded)</title>
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0;font-family:Arial,Helvetica,sans-serif}
    body{max-width:1100px;margin:0 auto;padding:20px;background:#f5f5f5}
    h1{text-align:center;margin-bottom:20px;color:#333}
    .container{display:flex;flex-direction:column;gap:20px}
    .connection-panel,.chat-panel,.media-panel,.file-panel,.stream-panel{
      background:#fff;padding:15px;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,.08)
    }
    .input-group{display:flex;gap:10px;margin-bottom:10px}
    input,button{padding:10px 12px;border:1px solid #ddd;border-radius:6px}
    input{flex:1}
    button{background:#4CAF50;color:#fff;border:none;cursor:pointer;transition:background .2s}
    button:hover{background:#45a049}
    button.secondary{background:#2196F3}
    button.secondary:hover{background:#0b7dda}
    button.warn{background:#9C27B0}
    button.warn:hover{background:#7b1fa2}
    button:disabled{background:#ccc;cursor:not-allowed}
    #chatMessages{height:200px;overflow-y:auto;border:1px solid #ddd;padding:10px;margin-bottom:10px;border-radius:6px}
    .message{margin-bottom:8px;padding:6px 8px;border-radius:6px;line-height:1.35}
    .local{background:#e6f7ff;text-align:right}
    .remote{background:#f0f0f0}
    .video-container{position:relative;width:100%;max-width:820px;margin:0 auto;background:#000;border-radius:12px;overflow:hidden}
    #remoteVideo{width:100%;height:auto;display:block}
    #localVideo{
      position:absolute;bottom:20px;right:20px;width:40%;max-width:320px;height:auto;border:2px solid #fff;border-radius:8px;z-index:10
    }
    .stream-video-container{display:flex;flex-direction:column;gap:16px;margin-bottom:10px;align-items:center}
    .stream-video{width:100%;max-width:900px;background:#000;border-radius:12px;overflow:hidden}
    .stream-video video{width:100%;height:auto;display:block}
    .file-info{margin-top:10px;padding:10px;background:#f9f9f9;border-radius:6px;display:block}
    .status{margin-top:10px;font-style:italic;color:#666}
    .typing-indicator{height:20px;color:#666;font-style:italic;margin-bottom:5px;visibility:hidden}
    .id-section{display:flex;align-items:center;gap:10px;margin-bottom:10px}
    .connection-status{display:inline-block;width:12px;height:12px;border-radius:50%;margin-right:6px;border:1px solid #ddd}
    .status-connected{background:#4CAF50}
    .status-connecting{background:#FFC107}
    .status-disconnected{background:#F44336}
    .status-error{background:#F44336}
    .transfer-list{display:flex;flex-direction:column;gap:8px}
    .transfer-item{padding:8px;border:1px solid #eee;border-radius:8px;background:#fff}
    .transfer-top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px}
    .transfer-name{font-weight:bold;word-break:break-all}
    .progress-bar{width:100%;height:8px;background:#eee;border-radius:999px;overflow:hidden}
    .progress{height:100%;width:0%}
    .progress[data-type="send"]{background:#4CAF50}
    .progress[data-type="recv"]{background:#2196F3}
    .file-link{display:inline-block;margin-top:6px;text-decoration:underline;color:#2196F3;cursor:pointer}
    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:9999}
    .modal{background:#111;color:#fff;width:min(92vw,900px);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.3);overflow:hidden}
    .modal-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:#1c1c1c}
    .modal-header button{background:#e0e0e0;color:#111;border:none;border-radius:6px;padding:8px 10px}
    .modal-body{padding:12px}
    .modal-body img,.modal-body video{width:100%;height:auto;display:block;border-radius:8px;background:#000}
    .player-controls{display:flex;align-items:center;gap:10px;margin-top:10px}
    .player-controls button{background:#4CAF50}
    .player-controls input[type="range"]{flex:1}
    @media (max-width:560px){
      #localVideo{width:45%;max-width:50vw}
    }
  </style>
</head>
<body>
<h1>Simple WebRTC Chat</h1>

<div class="container">
  <div class="connection-panel">
    <h2>Connection</h2>
    <div class="id-section">
      <span>Your ID: <strong id="myId">Generating...</strong></span>
      <button id="copyIdButton" class="secondary" disabled>Copy ID</button>
    </div>
    <div class="input-group">
      <input type="text" id="peerIdInput" placeholder="Enter peer ID to connect"/>
      <button id="connectButton">Connect</button>
    </div>
    <div class="status">
      <span class="connection-status status-disconnected" id="statusDot"></span>
      Status: <span id="connectionStatus">Disconnected</span>
    </div>
  </div>

  <div class="chat-panel">
    <h2>Chat</h2>
    <div id="chatMessages"></div>
    <div id="typingIndicator" class="typing-indicator"></div>
    <div class="input-group">
      <input type="text" id="messageInput" placeholder="Type your message" disabled/>
      <button id="sendMessageButton" disabled>Send</button>
    </div>
  </div>

  <div class="media-panel">
    <h2>Video & Voice Call</h2>
    <div class="video-container">
      <video id="remoteVideo" autoplay playsinline></video>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div class="input-group">
      <button id="startVideoButton">Start Video</button>
      <button id="startVoiceButton" class="secondary">Voice Call</button>
      <button id="endCallButton" class="warn" disabled>End Call</button>
    </div>
  </div>

  <div class="stream-panel">
    <h2>Video Streaming</h2>
    <div class="stream-video-container">
      <div class="stream-video">
        <video id="localStreamVideo" controls></video>
      </div>
      <div class="stream-video">
        <video id="remoteStreamVideo" controls></video>
      </div>
    </div>
    <div class="input-group">
      <input type="file" id="streamFileInput" accept="video/*"/>
      <button id="startStreamButton" disabled>Start Stream</button>
      <button id="stopStreamButton" class="warn" disabled>Stop Stream</button>
    </div>
  </div>

  <div class="file-panel">
    <h2>File Sharing</h2>
    <div class="input-group">
      <button id="btnShareDownloadable" class="secondary">Share downloadable files</button>
      <button id="btnShareNonDownloadable" class="warn">Share non downloadable files</button>
    </div>
    <div id="fileInfo" class="file-info">
      <div style="margin-bottom:6px;color:#555;">
        <strong>Transfers & Received Files</strong>
      </div>
      <div id="transferList" class="transfer-list"></div>
    </div>

    <!-- Hidden pickers -->
    <input type="file" id="pickDownloadable" multiple style="display:none"/>
    <input type="file" id="pickNonDownloadable" multiple accept="image/*,video/*" style="display:none"/>
  </div>
</div>

<!-- Modal -->
<div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
  <div class="modal">
    <div class="modal-header">
      <div id="modalTitle">Preview</div>
      <button id="modalBackBtn">Back</button>
    </div>
    <div class="modal-body" id="modalBody">
      <!-- dynamic -->
    </div>
  </div>
</div>

<script>
/* =======================
   Config & Globals
======================= */
const config = {
  iceServers: [
    { urls:'stun:stun.l.google.com:19302'},
    { urls:'stun:stun1.l.google.com:19302'},
    { urls:'stun:stun2.l.google.com:19302'},
    { urls:'stun:stun3.l.google.com:19302'},
    { urls:'stun:stun4.l.google.com:19302'}
  ]
};

let peer, connection, dataChannel;
let localStream, remoteStream, isCaller = false, connectedPeerId = null, typingTimer = null;
let streamCall = null;

/* File transfer (128KB chunks) */
const CHUNK_SIZE = 128 * 1024;
const sendingTransfers = new Map();   // id -> {file, offset, total, name, size, mime, category, ui}
const receivingTransfers = new Map(); // id -> {chunks:[], received, total, meta, ui}

/* =======================
   DOM
======================= */
const myIdElement = document.getElementById('myId');
const connectionStatusElement = document.getElementById('connectionStatus');
const statusDot = document.getElementById('statusDot');
const copyIdButton = document.getElementById('copyIdButton');
const peerIdInput = document.getElementById('peerIdInput');
const connectButton = document.getElementById('connectButton');
const messageInput = document.getElementById('messageInput');
const sendMessageButton = document.getElementById('sendMessageButton');
const chatMessages = document.getElementById('chatMessages');
const typingIndicator = document.getElementById('typingIndicator');
const startVideoButton = document.getElementById('startVideoButton');
const startVoiceButton = document.getElementById('startVoiceButton');
const endCallButton = document.getElementById('endCallButton');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const streamFileInput = document.getElementById('streamFileInput');
const startStreamButton = document.getElementById('startStreamButton');
const stopStreamButton = document.getElementById('stopStreamButton');
const localStreamVideo = document.getElementById('localStreamVideo');
const remoteStreamVideo = document.getElementById('remoteStreamVideo');
const btnShareDownloadable = document.getElementById('btnShareDownloadable');
const btnShareNonDownloadable = document.getElementById('btnShareNonDownloadable');
const pickDownloadable = document.getElementById('pickDownloadable');
const pickNonDownloadable = document.getElementById('pickNonDownloadable');
const transferList = document.getElementById('transferList');

/* Modal */
const modalBackdrop = document.getElementById('modalBackdrop');
const modalBackBtn = document.getElementById('modalBackBtn');
const modalBody = document.getElementById('modalBody');
const modalTitle = document.getElementById('modalTitle');

/* =======================
   PeerJS Init
======================= */
function initializePeer() {
  peer = new Peer({ config, debug: 2 });

  peer.on('open', id => {
    myIdElement.textContent = id;
    updateConnectionStatus('disconnected', 'Ready to connect');
    copyIdButton.disabled = false;
  });

  peer.on('connection', conn => {
    if (connection && connection.open) { conn.close(); return; }
    connectedPeerId = conn.peer;
    setupDataConnection(conn);
    peerIdInput.value = conn.peer;
    connectButton.disabled = true;
  });

  peer.on('call', call => {
    // Answer with our current localStream (video/voice) if present, else undefined
    call.answer(localStream || undefined);

    trackRTCPeerConnection(call.peerConnection, 'Media');

    call.on('stream', stream => {
      // If our main remoteVideo is empty, treat as call; else treat as remote stream
      if (!remoteVideo.srcObject) {
        remoteStream = stream;
        remoteVideo.srcObject = stream;
        endCallButton.disabled = false;
      } else {
        remoteStreamVideo.srcObject = stream;
      }
    });

    call.on('close', () => {
      endCall();
      stopStreaming();
    });

    call.on('error', err => {
      console.error('Call error:', err);
      updateConnectionStatus('error', 'Media error');
    });
  });

  peer.on('disconnected', () => {
    updateConnectionStatus('disconnected', 'Peer disconnected');
    resetConnectionState();
  });

  peer.on('error', err => {
    console.error('PeerJS error:', err);
    updateConnectionStatus('error', 'Error: ' + err.type);
  });
}

/* =======================
   UI: Connection Status
======================= */
function updateConnectionStatus(state, message){
  connectionStatusElement.textContent = message;
  statusDot.className = 'connection-status';
  if (state === 'connected') statusDot.classList.add('status-connected');
  else if (state === 'connecting') statusDot.classList.add('status-connecting');
  else if (state === 'error') statusDot.classList.add('status-error');
  else statusDot.classList.add('status-disconnected');
}

/* Monitor real-time state from RTCPeerConnection for both data & media */
function trackRTCPeerConnection(pc, label='Data'){
  if (!pc) return;
  const handler = () => {
    const s = pc.connectionState || pc.iceConnectionState;
    if (s === 'connected') updateConnectionStatus('connected', `${label} connected`);
    else if (s === 'connecting' || s === 'checking') updateConnectionStatus('connecting', `${label} connecting...`);
    else if (s === 'disconnected') updateConnectionStatus('disconnected', `${label} disconnected`);
    else if (s === 'failed') updateConnectionStatus('error', `${label} failed`);
    else if (s === 'closed') updateConnectionStatus('disconnected', `${label} closed`);
  };
  pc.onconnectionstatechange = handler;
  pc.oniceconnectionstatechange = handler;
  handler();
}

/* =======================
   Data Connection Setup
======================= */
function setupDataConnection(conn){
  connection = conn;
  connection.on('open', () => {
    dataChannel = connection;
    updateConnectionStatus('connected', 'Connected to ' + connection.peer);
    messageInput.disabled = false;
    sendMessageButton.disabled = false;
    startStreamButton.disabled = false;
    connectedPeerId = connection.peer;

    // Real-time connection monitoring
    trackRTCPeerConnection(connection.peerConnection, 'Data');

    setupDataChannel();
  });
  connection.on('close', () => {
    updateConnectionStatus('disconnected', 'Connection closed');
    resetConnectionState();
  });
  connection.on('error', err => {
    console.error('Connection error:', err);
    updateConnectionStatus('error', 'Connection error');
  });
}

function setupDataChannel(){
  dataChannel.on('data', handleDataMessage);
}

/* =======================
   Chat
======================= */
function handleDataMessage(data){
  if (!data) return;
  switch(data.type){
    case 'chat':
      addMessage(data.message, 'remote');
      break;
    case 'typing-start':
      typingIndicator.textContent = 'Peer is typing...';
      typingIndicator.style.visibility = 'visible';
      break;
    case 'typing-stop':
      typingIndicator.style.visibility = 'hidden';
      break;
    /* File transfer protocol */
    case 'file-meta':
      startReceivingFile(data.meta);
      break;
    case 'file-chunk':
      receiveFileChunk(data.id, data.seq, data.total, data.chunk);
      break;
    case 'file-complete':
      finalizeReceivedFile(data.id);
      break;
    case 'file-progress':
      updateSendProgressUI(data.id, data.percent);
      break;
    default:
      // ignore
      break;
  }
}

function addMessage(message, type){
  const el = document.createElement('div');
  el.classList.add('message', type);
  el.textContent = message;
  chatMessages.appendChild(el);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function sendMessage(){
  const message = messageInput.value.trim();
  if (message && dataChannel){
    dataChannel.send({type:'chat', message});
    addMessage(message, 'local');
    messageInput.value = '';
  }
}

function handleTyping(){
  if (!dataChannel) return;
  dataChannel.send({type:'typing-start'});
  if (typingTimer) clearTimeout(typingTimer);
  typingTimer = setTimeout(() => dataChannel?.send({type:'typing-stop'}), 1000);
}

/* =======================
   Calls (Video / Voice)
======================= */
async function startVideoCall(){
  try{
    localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
    localVideo.srcObject = localStream;
    startCall();
  }catch(e){ alert('Could not access camera/mic'); }
}

async function startVoiceCall(){
  try{
    localStream = await navigator.mediaDevices.getUserMedia({video:false, audio:true});
    startCall();
  }catch(e){ alert('Could not access microphone'); }
}

function startCall(){
  if (!connection) return alert('Connect to a peer first');
  isCaller = true;
  endCallButton.disabled = false;
  const call = peer.call(connection.peer, localStream);
  trackRTCPeerConnection(call.peerConnection, 'Media');
  call.on('stream', stream => {
    remoteStream = stream;
    remoteVideo.srcObject = stream;
  });
  call.on('close', endCall);
  call.on('error', err => {
    console.error(err);
    updateConnectionStatus('error', 'Media error');
  });
}

function endCall(){
  if (localStream){
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
    localVideo.srcObject = null;
  }
  if (remoteStream){
    remoteStream.getTracks().forEach(t => t.stop());
    remoteStream = null;
    remoteVideo.srcObject = null;
  }
  endCallButton.disabled = true;
}

/* =======================
   Synchronized Streaming
======================= */
async function startStreaming(){
  if (!connection) return alert('Please connect first');
  const file = streamFileInput.files[0];
  if (!file) return alert('Select a video file first');
  const fileURL = URL.createObjectURL(file);
  localStreamVideo.src = fileURL;
  localStreamVideo.onloadedmetadata = async () => {
    await localStreamVideo.play();
    if (!localStreamVideo.captureStream){
      alert("Your browser doesn't support captureStream");
      return;
    }
    const mediaStream = localStreamVideo.captureStream();
    streamCall = peer.call(connection.peer, mediaStream);
    trackRTCPeerConnection(streamCall.peerConnection, 'Stream');
    streamCall.on('stream', rStream => {
      remoteStreamVideo.srcObject = rStream;
    });
    streamCall.on('close', stopStreaming);
    startStreamButton.disabled = true;
    stopStreamButton.disabled = false;
  };
}

function stopStreaming(){
  if (streamCall){
    try{ streamCall.close(); }catch{}
    streamCall = null;
  }
  localStreamVideo.pause();
  localStreamVideo.src = '';
  remoteStreamVideo.srcObject = null;
  startStreamButton.disabled = false;
  stopStreamButton.disabled = true;
}

/* =======================
   File Transfer (Chunked, 128KB)
======================= */
function uuid(){
  return 'f-' + Math.random().toString(36).slice(2) + '-' + Date.now().toString(36);
}

function humanSize(bytes){
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1048576) return (bytes/1024).toFixed(1) + ' KB';
  return (bytes/1048576).toFixed(1) + ' MB';
}

/* UI helpers for transfers */
function createTransferUI(id, name, size, type){
  const wrap = document.createElement('div');
  wrap.className = 'transfer-item';
  wrap.id = `xfer-${id}`;

  const top = document.createElement('div');
  top.className = 'transfer-top';

  const nameEl = document.createElement('div');
  nameEl.className = 'transfer-name';
  nameEl.textContent = `${name} (${humanSize(size)})`;
  top.appendChild(nameEl);

  const pctEl = document.createElement('div');
  pctEl.id = `pct-${id}`;
  pctEl.textContent = '0%';
  top.appendChild(pctEl);

  const bar = document.createElement('div');
  bar.className = 'progress-bar';
  const prog = document.createElement('div');
  prog.className = 'progress';
  prog.dataset.type = type; // 'send' or 'recv'
  prog.style.width = '0%';
  bar.appendChild(prog);

  wrap.appendChild(top);
  wrap.appendChild(bar);

  transferList.appendChild(wrap);
  return {wrap, pctEl, prog};
}

function updateProgressUI(id, percent){
  const pctEl = document.getElementById(`pct-${id}`);
  const prog = document.querySelector(`#xfer-${id} .progress`);
  if (pctEl) pctEl.textContent = `${percent}%`;
  if (prog) prog.style.width = `${percent}%`;
}

/* Sender: iterate chunks and send */
async function sendFileAsChunks(file, category){
  if (!dataChannel) return;
  const id = uuid();
  const meta = { id, name: file.name, size: file.size, mime: file.type || 'application/octet-stream', category };
  const ui = createTransferUI(id, file.name, file.size, 'send');

  sendingTransfers.set(id, { file, offset: 0, total: file.size, name:file.name, size:file.size, mime:meta.mime, category, ui });

  // Send meta
  dataChannel.send({ type: 'file-meta', meta });

  const reader = new FileReader();

  let offset = 0;
  let seq = 0;
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

  function readSlice(o){
    const slice = file.slice(o, o + CHUNK_SIZE);
    reader.readAsArrayBuffer(slice);
  }

  reader.onload = () => {
    const chunk = reader.result; // ArrayBuffer
    dataChannel.send({ type:'file-chunk', id, seq, total: totalChunks, chunk });

    offset += chunk.byteLength;
    seq += 1;

    // Update local (sender) progress; use receiver echo for synchronized updates too
    const percent = Math.min(100, Math.floor((offset / file.size) * 100));
    updateProgressUI(id, percent);

    if (offset < file.size){
      readSlice(offset);
    }else{
      dataChannel.send({ type:'file-complete', id });
    }
  };

  readSlice(0);
}

/* Receiver: initialize structure on meta */
function startReceivingFile(meta){
  const { id, name, size, category } = meta;
  const ui = createTransferUI(id, name, size, 'recv');
  receivingTransfers.set(id, { chunks: [], received: 0, total: size, meta, ui });
}

/* Receiver: collect chunks */
function receiveFileChunk(id, seq, total, chunk){
  const rcv = receivingTransfers.get(id);
  if (!rcv) return;
  // Ensure array size
  if (!rcv.chunks[seq]) rcv.chunks[seq] = new Uint8Array(chunk);
  rcv.received += (chunk.byteLength || chunk.size || 0);

  const pct = Math.min(100, Math.floor((rcv.received / rcv.total) * 100));
  updateProgressUI(id, pct);

  // echo progress back to sender for synchronized progress
  dataChannel?.send({ type: 'file-progress', id, percent: pct });

  // if all chunks received? (simple check)
  if (rcv.chunks.filter(Boolean).length === total){
    finalizeReceivedFile(id);
  }
}

/* Sender receives echoed progress */
function updateSendProgressUI(id, percent){
  updateProgressUI(id, Math.max(0, Math.min(100, Math.floor(percent))));
}

/* Receiver: finalize and render link or modal opener */
function finalizeReceivedFile(id){
  const rcv = receivingTransfers.get(id);
  if (!rcv) return;

  // Build Blob
  const blob = new Blob(rcv.chunks, { type: rcv.meta.mime });
  const url = URL.createObjectURL(blob);

  const parent = document.getElementById(`xfer-${id}`);
  if (!parent) return;

  const line = document.createElement('div');
  line.style.marginTop = '6px';

  const link = document.createElement('a');
  link.className = 'file-link';
  link.textContent = rcv.meta.category === 'downloadable' ? 'Download file' : 'Open preview';
  link.href = rcv.meta.category === 'downloadable' ? url : 'javascript:void(0)';
  if (rcv.meta.category === 'downloadable'){
    link.download = rcv.meta.name || 'file';
  }else{
    link.addEventListener('click', () => openPreviewModal(rcv.meta.name, url, rcv.meta.mime));
  }

  line.appendChild(link);
  parent.appendChild(line);

  updateProgressUI(id, 100);
  receivingTransfers.delete(id);
}

/* =======================
   Modal Preview (non-downloadable)
   - images or videos
   - video: custom play/pause + external seeker
======================= */
function openPreviewModal(name, url, mime){
  modalTitle.textContent = name || 'Preview';
  modalBody.innerHTML = '';

  if (mime.startsWith('image/')){
    const img = document.createElement('img');
    img.src = url;
    img.alt = name || 'image';
    modalBody.appendChild(img);
  } else if (mime.startsWith('video/')){
    const vid = document.createElement('video');
    vid.src = url;
    vid.playsInline = true;
    vid.controls = false; // custom only
    vid.id = 'customVideo';
    modalBody.appendChild(vid);

    const controls = document.createElement('div');
    controls.className = 'player-controls';

    const btn = document.createElement('button');
    btn.textContent = 'Play';
    btn.addEventListener('click', () => {
      if (vid.paused){ vid.play(); btn.textContent = 'Pause'; }
      else { vid.pause(); btn.textContent = 'Play'; }
    });

    const seek = document.createElement('input');
    seek.type = 'range';
    seek.min = 0; seek.max = 1000; seek.value = 0;
    seek.addEventListener('input', () => {
      if (vid.duration && isFinite(vid.duration)){
        vid.currentTime = (seek.value/1000) * vid.duration;
      }
    });
    vid.addEventListener('timeupdate', () => {
      if (vid.duration && isFinite(vid.duration)){
        seek.value = Math.floor((vid.currentTime / vid.duration) * 1000);
      }
    });

    controls.appendChild(btn);
    controls.appendChild(seek);
    modalBody.appendChild(controls);
  } else {
    const p = document.createElement('p');
    p.textContent = 'This preview only supports images and videos.';
    modalBody.appendChild(p);
  }

  modalBackdrop.style.display = 'flex';
  modalBackdrop.setAttribute('aria-hidden', 'false');
}

modalBackBtn.addEventListener('click', () => {
  modalBackdrop.style.display = 'none';
  modalBackdrop.setAttribute('aria-hidden', 'true');
  modalBody.innerHTML = '';
});

/* =======================
   Connection Actions
======================= */
function connectToPeer(){
  const peerId = peerIdInput.value.trim();
  if (!peerId) return;
  updateConnectionStatus('connecting', 'Connecting to ' + peerId);
  connectedPeerId = peerId;
  const conn = peer.connect(peerId, { reliable: true });
  setupDataConnection(conn);
  connectButton.disabled = true;
}

function copyIdToClipboard(){
  const id = myIdElement.textContent;
  navigator.clipboard.writeText(id).then(() => {
    const original = copyIdButton.textContent;
    copyIdButton.textContent = 'Copied!';
    setTimeout(() => copyIdButton.textContent = original, 1500);
  });
}

function resetConnectionState(){
  messageInput.disabled = true;
  sendMessageButton.disabled = true;
  startStreamButton.disabled = true;
  stopStreamButton.disabled = true;
  connectButton.disabled = false;
  typingIndicator.style.visibility = 'hidden';
  endCall();
  stopStreaming();
}

/* =======================
   Event Listeners
======================= */
connectButton.addEventListener('click', connectToPeer);
copyIdButton.addEventListener('click', copyIdToClipboard);
sendMessageButton.addEventListener('click', sendMessage);
messageInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendMessage(); });
messageInput.addEventListener('input', handleTyping);
startVideoButton.addEventListener('click', startVideoCall);
startVoiceButton.addEventListener('click', startVoiceCall);
endCallButton.addEventListener('click', endCall);
startStreamButton.addEventListener('click', startStreaming);
stopStreamButton.addEventListener('click', stopStreaming);
streamFileInput.addEventListener('change', () => { startStreamButton.disabled = !streamFileInput.files[0]; });

/* File sharing buttons */
btnShareDownloadable.addEventListener('click', () => {
  pickDownloadable.click();
});
btnShareNonDownloadable.addEventListener('click', () => {
  alert('Non downloadable accepts only images and videos. They will open in a preview modal.');
  pickNonDownloadable.click();
});

/* Handle chosen files */
pickDownloadable.addEventListener('change', () => {
  if (!dataChannel) return alert('Connect first');
  const files = Array.from(pickDownloadable.files || []);
  files.forEach(f => sendFileAsChunks(f, 'downloadable'));
  // reset input so the same file can be re-chosen later
  pickDownloadable.value = '';
});
pickNonDownloadable.addEventListener('change', () => {
  if (!dataChannel) return alert('Connect first');
  const files = Array.from(pickNonDownloadable.files || []);
  files.forEach(f => sendFileAsChunks(f, 'non-downloadable'));
  pickNonDownloadable.value = '';
});

/* =======================
   Initialize
======================= */
initializePeer();
</script>
</body>
</html>
